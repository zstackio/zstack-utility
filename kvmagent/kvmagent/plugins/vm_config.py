import os

import libvirt
from jinja2 import Template
from ruamel import yaml
from ruamel.yaml.comments import CommentedMap
from abc import ABCMeta, abstractmethod

from zstacklib.utils import log
from zstacklib.utils import linux
from zstacklib.utils import jsonobject
from zstacklib.utils import http
from zstacklib.utils import ip
from zstacklib.utils.qga import *

from kvmagent import kvmagent
from kvmagent.plugins import vm_plugin

ZSTACK_START_COMMENT = "Generated by zstack customization engine. Do not edit."

logger = log.get_logger(__name__)


class VmConfigDriverBase(object):
    __metaclass__ = ABCMeta

    def __init__(self, qga):
        self.qga = qga
        self.driver_name = 'base'
        self.nm_soft_type = None
        self.nm_driver = None
        self.config_persist_driver = None

    def _get_nm_soft_type(self):
        if self.qga.guest_exec_bash_no_exitcode("ps -C systemd-networkd | grep systemd-network", exception=False):
            return LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_SYSTEMD
        elif self.qga.guest_exec_bash_no_exitcode("ps -C NetworkManager | grep NetworkManager", exception=False):
            return LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM

        return LinuxVmConfigDriverBase.LINUX_NM_TYPE_NONE

    @staticmethod
    def _set_mn_driver(func):
        def set_driver(self, config):
            if not self.nm_soft_type:
                self.nm_soft_type = self._get_nm_soft_type()
            if not self.nm_driver:
                self.nm_driver = self.get_nm_driver()
            if not self.config_persist_driver:
                self.config_persist_driver = self.get_config_persist_driver()
            logger.debug('_set_mn_driver, nm_soft_type={}, nm_driver={}, config_persist_driver={}'
                         .format(self.nm_soft_type, self.nm_driver.__class__.__name__,
                                 self.config_persist_driver.__class__.__name__))
            return func(self, config)

        return set_driver

    def get_nm_driver(self):
        qga = self.qga
        if qga.guest_exec_bash_no_exitcode("which netplan", exception=False) \
                and self.nm_soft_type in (
                LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM, LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_SYSTEMD):
            return LinuxNmNetplanDriver(qga)
        if self.nm_soft_type == LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM:
            if self.qga.os in [VM_OS_LINUX_UBUNTU, VM_OS_LINUX_DEBIAN, VM_OS_LINUX_UOS]:
                if self.qga.guest_exec_bash_no_exitcode(
                        "cat /etc/NetworkManager/NetworkManager.conf | grep '^[ ]*managed[ ]*=[ ]*true'",
                        exception=False):
                    # return LinuxNmIfUpDownDriver(qga)
                    return LinuxNmNmcliDriver(qga, True)
            else:
                return LinuxNmNmcliDriver(qga, False)

        return LinuxNmIprouteDriver(qga)

    def get_config_persist_driver(self):
        if self.nm_driver.driver_type == VmNetworkManagerBase.VM_NM_DRIVER_NETPLAN:
            return NetplanPersistDriver(self.qga, self.nm_soft_type)
        elif self.driver_name == "centos":
            return CentosPersistDriver(self.qga, self.nm_soft_type)
        elif self.driver_name == "ubuntu":
            return UbuntuPersistDriver(self.qga, self.nm_soft_type)
        else:
            raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL,
                               'not support vm_config_driver %s nm_driver %s' % (self.driver_name, self.nm_driver))

    @staticmethod
    def get_driver(domain):
        qga = Qga(domain)
        if qga.state != Qga.QGA_STATE_RUNNING:
            raise QgaException(ERROR_CODE_QGA_NOT_RUNNING, 'qga state not running for vm {}'.format(domain.name()))
        if qga.os not in VM_CONFIG_SYNC_OS_VERSION_SUPPORT.keys() or \
                qga.os_version not in VM_CONFIG_SYNC_OS_VERSION_SUPPORT[qga.os]:
            raise QgaException(ERROR_CODE_QGA_OS_NOT_SUPPORT, 'not support for os {} {}'.format(qga.os, qga.os_version))

        if qga.os in (VM_OS_LINUX_CENTOS, VM_OS_LINUX_KYLIN):
            vm_config_driver = CentOSVmConfigDriver(qga)
        elif qga.os == VM_OS_LINUX_UOS and qga.os_id_like and 'fedora' in qga.os_id_like:
            vm_config_driver = CentOSVmConfigDriver(qga)
        elif qga.os in (VM_OS_LINUX_UBUNTU, VM_OS_LINUX_UOS):
            vm_config_driver = UbuntuVmConfigDriver(qga)
        return vm_config_driver

    @abstractmethod
    def config_ports(self, ports_config):
        pass


class LinuxVmConfigDriverBase(VmConfigDriverBase):
    LINUX_NM_SOFT_TYPE_NM = "network_manager"
    LINUX_NM_SOFT_TYPE_SYSTEMD = "systemd"
    LINUX_NM_TYPE_NONE = "none"

    def __init__(self, qga):
        VmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'linux'

    def _get_phy_interfaces(self):
        ret = self.qga.guest_exec_bash_no_exitcode("ls -l /sys/class/net/*/device", exception=False)
        if not ret:
            return None
        '''
        the format of "ret" like this:
        lrwxrwxrwx 1 root root 0 Nov 21 18:04 /sys/class/net/enp101s0f0/device -> ../../../0000:65:00.0
        '''
        phy_ports = [line.split("/")[4] for line in ret.split('\n') if len(line.split("/")) > 5]
        path_list = ["/sys/class/net/%s/address" % port for port in phy_ports]
        ret = self.qga.guest_exec_bash_no_exitcode("cat " + " ".join(path_list))
        if not ret:
            return None

        mac_list = [mac for mac in ret.split('\n') if ':' in mac]
        if len(phy_ports) != len(mac_list):
            raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL, 'get vm physical interface failed')

        return dict(zip(mac_list, phy_ports))

    def _set_port_name_for_config(self, ports_config):
        phy_ports = self._get_phy_interfaces()

        for port_config in ports_config.ports:
            if port_config.mac not in phy_ports:
                raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL,
                                   'get vm physical with mac {} failed'.format(port_config.mac))
            setattr(port_config, 'port_name', phy_ports[port_config.mac])

    @VmConfigDriverBase._set_mn_driver
    def config_ports(self, ports_config):
        vm_uuid = self.qga.vm_uuid
        self._set_port_name_for_config(ports_config)
        # persist config file
        self.config_persist_driver.persist_ports_config(ports_config)
        logger.debug('vm[{}] port config persistence success.'.format(vm_uuid))

        # reload config file
        self.nm_driver.reload_ports_config(ports_config)
        logger.debug('vm[{}] port config reload success.'.format(vm_uuid))

        # check whether the configuration has taken effect
        self.nm_driver.ports_config_checking(ports_config)
        logger.debug('vm[{}] port config checking success.'.format(vm_uuid))


class WindowsVmConfigDriverBase(VmConfigDriverBase):
    def __init__(self, qga):
        VmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'linux'

    @VmConfigDriverBase._set_mn_driver
    def config_ports(self, ports_config):
        raise QgaException(ERROR_CODE_QGA_OS_NOT_SUPPORT, 'not support windows')


class CentOSVmConfigDriver(LinuxVmConfigDriverBase):

    def __init__(self, qga):
        LinuxVmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'centos'


class UbuntuVmConfigDriver(LinuxVmConfigDriverBase):
    def __init__(self, qga):
        LinuxVmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'ubuntu'


'''
    class VmNetworkManagerBase: realize the effective way of vm network configuration
'''


class VmNetworkManagerBase(object):
    __metaclass__ = ABCMeta

    VM_NM_DRIVER_NETPLAN = 'netplan'
    VM_NM_DRIVER_NMCLI = 'nmcli'
    VM_NM_DRIVER_IFUPDPWN = 'ifupdown'
    VM_NM_DRIVER_IPROUTE = 'iproute'

    def __init__(self, qga):
        self.driver_type = "base"
        self.qga = qga

    @abstractmethod
    def reload_ports_config(self, ports_config):
        pass


class LinuxNmDriverBase(VmNetworkManagerBase):
    def __init__(self, qga):
        super(LinuxNmDriverBase, self).__init__(qga)
        self.driver_type = "linux_base"

    def reload_ports_config(self, ports_config):
        raise NotImplementedError()

    def _static_reload_dns(self, dns_list, port_name):
        if dns_list:
            bash_cmd = '''#!/bin/bash

ports_dns=({dns_list})
cur_dns=`cat /etc/resolv.conf`
delete=""
for dns in ${{ports_dns[@]}}
do
    delete=$delete"/${{dns}}/d;"
    dns_add=$dns_add"\nnameserver ${{dns}}"
done
if [ -x /sbin/resolvconf ] && /sbin/resolvconf --updates-are-enabled; then
    sleep 5
    #echo -n ${{dns_add}} | /sbin/resolvconf -a "${{port_name}}.dhclient"
    /sbin/resolvconf -u
else
    dns_reserve=`eval sed '${{delete}}' /etc/resolv.conf | grep '^[ ]*nameserver'`
    dns_config="# {zstack_comment}\n${{dns_add}}\n${{dns_reserve}}"
    echo -e "${{dns_config}}" > /etc/resolv.conf
fi
'''
            self.qga.guest_exec_bash(bash_cmd.format(dns_list=' '.join(dns_list),
                                                     zstack_comment=ZSTACK_START_COMMENT,
                                                     port_name=port_name), False)

    @staticmethod
    def port_config_checking(qga, port_config):
        bash_cmd = '''#!/bin/bash
if [[ $(ip addr ls dev {{ port_name }} | grep {{ ip_address }}/{{ prefix_len }}) == "" ]];then
    exit 11
fi
gw_config=""
{%- if gateway %}
gw_config={{ gateway }}
if [[ $(ip route | grep "default via {{ gateway }} dev {{ port_name }}") == "" ]];then
    exit 21
fi
{%- endif %}
{%- if mtu %}
dev_mtu=`cat /sys/class/net/{{ port_name }}/mtu`
if [[ ${dev_mtu} -ge {{ mtu }} && $(ip link ls dev {{ port_name }} | grep 'mtu {{ mtu }}') == "" ]];then
    exit 31
fi
{%- endif %}
{%- if dns %}
    cur_dns=$(cat /etc/resolv.conf | grep '^nameserver' | awk -F ' ' '{print $2}')
    first_dns=$(echo $cur_dns | awk -F ' ' '{print $1}')
    if [[ $first_dns == "127.0.0.53" && $(which resolvectl) != "" ]]; then
        cur_dns=$(resolvectl dns {{ port_name }} | awk -F ':' '{ print $2}')
    fi
    cur_dns=`echo $cur_dns`
    if [[ $gw_config != "" && $(echo $cur_dns | grep "^{{ dns }}") == "" ]]; then
        exit 41
    fi
{%- endif %}

exit 0
'''

        template = Template(bash_cmd)
        ip_config = port_config.vmIps[0]
        conf = template.render(port_name=port_config.port_name,
                               ip_address=ip_config.ip,
                               prefix_len=ip.get_prefix_len_by_netmask(ip_config.netmask),
                               gateway=ip_config.gateway,
                               mtu=port_config.mtu,
                               dns=' '.join(ip_config.dns) if ip_config.dns else None)
        exitcode, ret_data = qga.guest_exec_bash(conf)
        item = ''
        if exitcode == 0:
            return 0, ''
        elif exitcode == 11:
            err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_IP
            item = 'ip address'
        elif exitcode == 21:
            err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_GW
            item = 'gateway'
        elif exitcode == 31:
            err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_MTU
            item = 'mtu'
        elif exitcode == 41:
            err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_DNS
            item = 'dns'
        else:
            item = 'config'
            err_code = ERROR_CODE_QGA_COMMAND_ERROR
        return err_code, 'vm {} port {} {} config not effective, ret {}'.format(
            qga.vm_uuid, port_config.port_name, item, ret_data)

    @linux.retry(times=6, sleep_time=2)
    def ports_config_checking(self, ports_config):
        for port_config in ports_config.ports:
            err_code, err_msg = LinuxNmDriverBase.port_config_checking(self.qga, port_config)
            if err_code != 0:
                raise QgaException(err_code, err_msg)


class LinuxNmNmcliDriver(LinuxNmDriverBase):
    def __init__(self, qga, accurate=False):
        super(LinuxNmNmcliDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_NMCLI
        self.accurate = accurate

    def reload_ports_config(self, ports_config):
        ports = [port_config.port_name for port_config in ports_config.ports]

        # note: 'nmcli conn reload' working normally in centos, but abnormally in ubuntu.
        if self.accurate:
            bash_cmd = '''#!/bin/bash
ports_list=({ports_list})
config_list=({config_list})
for (( i = 0 ; i < ${{#ports_list[@]}} ; i++ ))
do
    port_name=${{ports_list[$i]}}

    uuid=$(nmcli -m tabular -t -f GENERAL.CON-UUID device show $port_name)
    if [[ $uuid == "" ]];then
        nmcli -w 1 device connect $port_name 2> /dev/null
        uuid=$(nmcli -m tabular -t -f GENERAL.CON-UUID device show $port_name)
    fi

    if [[ $uuid == "" ]];then
        continue
    fi

    config=${{config_list[$i]}}
    eval nmcli -w 1 conn modify $uuid $config 2>/dev/null
    nmcli -w 1 conn down $uuid 2>/dev/null
    nmcli -w 1 conn up $uuid 2>/dev/null
done
'''
            configs = []
            for port_config in ports_config.ports:
                config = []
                ip_config = port_config.vmIps[0]
                config.append('ipv4.method {}'.format('auto' if ip_config.proto == 'dhcp' else 'manual'))
                if ip_config.proto == 'static':
                    config.append('ipv4.address {}/{}'.format(ip_config.ip,
                                                              ip.get_prefix_len_by_netmask(ip_config.netmask)))
                    if ip_config.gateway:
                        config.append('ipv4.gateway {}'.format(ip_config.gateway))
                    else:
                        config.append("ipv4.gateway ''")

                    if ip_config.dns:
                        config.append("ipv4.dns '{}'".format(' '.join(ip_config.dns)))
                    else:
                        config.append("ipv4.dns ''")

                    if port_config.mtu:
                        config.append('802-3-ethernet.mtu {}'.format(port_config.mtu))
                    else:
                        config.append('802-3-ethernet.mtu auto')
                else:
                    config.append("ipv4.address ''")
                    config.append("ipv4.gateway ''")
                    config.append("ipv4.dns ''")
                    config.append('802-3-ethernet.mtu auto')

                configs.append('"{}"'.format(' '.join(config)))
            ports_list = ' '.join(ports)
            config_list = ' '.join(configs)
            self.qga.guest_exec_bash(bash_cmd.format(ports_list=ports_list, config_list=config_list), output=False)
        else:
            bash_cmd = ['nmcli conn reload 2> /dev/null']
            for port_name in ports:
                bash_cmd.append('nmcli conn down {} 2> /dev/null; nmcli conn up {} 2> /dev/null'
                                .format(port_name, port_name))
        self.qga.guest_exec_bash(';'.join(bash_cmd), False)


class LinuxNmNetplanDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmNetplanDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_NETPLAN

    def reload_ports_config(self, ports_config):
        for port_config in ports_config.ports:
            ip_config = port_config.vmIps[0]
            if ip_config.proto == 'dhcp':
                self.qga.guest_exec_bash_no_exitcode('ip link set down dev {}'.format(port_config.port_name), False,
                                                     False)

        self.qga.guest_exec_bash('netplan apply 2> /dev/null', False)


class LinuxNmIfUpDownDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmIfUpDownDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_IFUPDPWN

    def reload_ports_config(self, ports_config):
        bash_cmd = '''#!/bin/bash
ports=({ports_list})
for port_name in ${{ports[@]}}
do
    port_name=${{ports[$i]}}
    nm=0
    if [[ $(ps -C NetworkManager | grep "NetworkManager") != "" ]];then
        nmcli -w 1 device disconnect $port_name 2> /dev/null
        nm=1
    fi
    ip -4 address flush dev $port_name 2> /dev/null
    ifdown $port_name 2> /dev/null
    ifup $port_name 2> /dev/null
done
'''
        ports_list = []
        dns_list = []
        dns_port = None
        for port_config in ports_config.ports:
            ports_list.append(port_config.port_name)
            ip_config = port_config.vmIps[0]
            if ip_config.dns and ip_config.gateway:
                dns_list = ip_config.dns
                dns_port = port_config.port_name

        self.qga.guest_exec_bash(bash_cmd.format(ports_list=' '.join(ports_list)), output=False)
        self._static_reload_dns(dns_list, dns_port)


class LinuxNmIprouteDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmIprouteDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_IPROUTE

    def reload_ports_config(self, ports_config):
        bash_cmd = '''#!/bin/bash
### stop nm connection
if [[ $(ps -C NetworkManager | grep "NetworkManager") != "" ]];then
    nmcli -w 1 device disconnect {{ port_name }} 2>/dev/null
fi

# stop dhclient
cur_dhclient=$(ps aux | grep dhclient | grep -v 'bash -c' | grep {{ port_name }})
pf=""
lf=""
if [[ $cur_dhclient != "" ]]; then
    pf=$(echo $cur_dhclient | awk -F '-pf' '{print $2}' | awk -F ' ' '{print $1}')
    if [[ $pf != "" ]]; then
        pf="-pf "$pf
    fi
    lf=$(echo $cur_dhclient | awk -F '-lf' '{print $2}' | awk -F ' ' '{print $1}')
    if [[ $lf != "" ]]; then
        lf="-lf "$lf
    fi

    $(which dhclient) -r {{ port_name }} $pf 2> /dev/null
fi

{% if proto == "static" -%}
    if [[ $(ip addr ls dev {{ port_name }} | grep {{ ip_address }}/{{ prefix_len }}) == "" ]];then
        ip -4 address flush dev {{ port_name }}
        ip -4 address add {{ ip_address }}/{{ prefix_len }} dev {{ port_name }}
    fi
    {%- if gateway %}
        if [[ $(ip route | grep "default via {{ gateway }} dev {{ port_name }}") == "" ]];then
            ip route add default via {{ gateway }} dev {{ port_name }}
        fi
    {%- endif %}
    {%- if mtu %}
        ip link set mtu {{ mtu }} dev {{ port_name }}
    {%- endif %}
{% else -%}
$(which dhclient) -1 -v -pf /run/dhclient.{{ port_name }}.pid -lf /var/lib/dhcp/dhclient.{{ port_name }}.leases -I {{ port_name }} 2> /dev/null
{%- endif %}
'''
        dns_list = []
        dns_port = None
        for port_config in ports_config.ports:
            ip_config = port_config.vmIps[0]
            if ip_config.dns and ip_config.gateway and ip_config.proto == 'static':
                dns_list = ip_config.dns
                dns_port = port_config.port_name

            template = Template(bash_cmd)
            conf = template.render(port_name=port_config.port_name,
                                   ip_address=ip_config.ip,
                                   proto=ip_config.proto,
                                   prefix_len=ip.get_prefix_len_by_netmask(ip_config.netmask),
                                   gateway=ip_config.gateway,
                                   mtu=port_config.mtu)
            self.qga.guest_exec_bash(conf, output=False)
        self._static_reload_dns(dns_list, dns_port)


'''
    class NetworkConfigPersistBase: for vm networking configuration persistent
'''


class NetworkConfigPersistBase(object):
    __metaclass__ = ABCMeta

    def __init__(self, qga, nm_soft_type):
        self.qga = qga
        self.nm_soft_type = nm_soft_type

    @staticmethod
    def zstack_config_file_name(suffix):
        return "99-zstack-net-cfg" + suffix

    @staticmethod
    def config_backup_name(file_name):
        return file_name + ".ZStackBackup"

    @staticmethod
    def config_start_comment():
        return ZSTACK_START_COMMENT

    def _write_config_file(self, path, content):
        ret = self.qga.guest_file_write(path, content)
        if ret != len(content):
            raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR, 'config file write error')

    def _read_config_file(self, path):
        _, content = self.qga.guest_file_read(path)
        return content

    def _backup_current_config(self, files_list):
        for path in files_list:
            self.qga.guest_exec_bash('\\cp %s %s' % (path, self.config_backup_name(path)), False)

    def _recover_current_config(self, files_list):
        for path in files_list:
            self.qga.guest_exec_bash('\\cp %s %s' % (self.config_backup_name(path), path), False)

    def _dns_config_persist(self, dns):
        if dns:
            content = '# {}\n\nnameserver {}'.format(self.config_start_comment(), dns)
            self._write_config_file('/etc/resolv.conf', content)

    def _get_vm_port_list(self):
        curr_port_list = []
        port_info = self.qga.guest_exec_bash_no_exitcode('ls /sys/class/net')
        if port_info:
            curr_port_list = [port for port in port_info.split('\n') if port != ""]
        return curr_port_list

    @abstractmethod
    def persist_ports_config(self, ports_config):
        pass


class NetplanPersistDriver(NetworkConfigPersistBase):
    # Not used, but reserved for reference
    config_temp = '''# Generated by zstack customization engine. Do not edit.
network:
  version: 2
  renderer: networkd
  ethernets:
    {{ iface_name }}:
      match:
        macaddress: {{ mac_address }}
      {% if mtu -%}
      mtu: {{ mtu }}
      {%- endif %}
      {% if proto == "static" -%}
      dhcp4: no
      addresses: [ {{ ip_address }}/{{ prefix_size }} ]
      {% if gateway -%}
      gateway4: {{ gateway }}
      {%- endif %}
      {% if dns -%}
      nameservers:
        addresses: [ {{ dns }} ]
      {%- endif %}
      {%- else %}
      dhcp4: yes
      {%- endif %}
'''

    def __init__(self, qga, nm_soft_type):
        super(NetplanPersistDriver, self).__init__(qga, nm_soft_type)

    @staticmethod
    def _netplan_config_with_commented_map(netplan_config):
        """
         map to commented_map, for the configuration to be written in order
        """
        config = CommentedMap()
        config.yaml_set_start_comment(NetworkConfigPersistBase.config_start_comment())
        network_commented = CommentedMap()
        network_config = netplan_config['network']
        if 'version' in network_config:
            network_commented['version'] = network_config['version']
            del network_config['version']
        if 'renderer' in network_config:
            network_commented['renderer'] = network_config['renderer']
            del network_config['renderer']
        if 'ethernets' in network_config:
            network_commented['ethernets'] = network_config['ethernets']
            del network_config['ethernets']
        for key, value in network_config.items():
            network_commented[key] = value
        config['network'] = network_commented
        del netplan_config['network']
        for key, value in netplan_config.items():
            config[key] = value
        return config

    @staticmethod
    def _erase_ports_config(netplan_config, ports_config):
        """
        Delete the configuration that will be overwritten and keep other configurations
        """
        modify = False
        for port_config in ports_config.ports:
            port_name = port_config.port_name
            if port_name not in netplan_config:
                continue

            if len(port_config.vmIps) == 0:
                continue

            netplan_port_config = netplan_config[port_name]
            ip_config = port_config.vmIps[0]
            if ip_config.version == 6:
                raise QgaException(ERROR_CODE_VM_CONFIG_IPV6_NOT_SUPPORT)

            if 'dhcp4' in netplan_port_config:
                del netplan_port_config['dhcp4']
                modify = True
            if 'gateway4' in netplan_port_config:
                del netplan_port_config['gateway4']
                modify = True
            if 'addresses' in netplan_port_config:
                ipv6_list = [ip for ip in netplan_port_config['addresses'] if not ip.is_ipv4(ip)]
                if len(ipv6_list) != len(netplan_port_config['addresses']):
                    netplan_port_config['addresses'] = ipv6_list
                    modify = True
            if ip_config.dns and 'nameservers' in netplan_port_config:
                del netplan_port_config['nameservers']
                modify = True
        return modify

    def _rectify_current_config(self, ports_config, files_list):
        """
        Delete the configuration that will be overwritten and keep other configurations.
        otherwise there will be a configuration conflict
        """
        for path in files_list:
            file_info = os.path.split(path)
            # skip zstack config file
            if len(file_info) == 2 and \
                    file_info[1] == self.zstack_config_file_name('.yaml'):
                continue

            content = self._read_config_file(path)
            if not content:
                continue
            netplan_config = yaml.load(content, Loader=yaml.RoundTripLoader)
            if 'network' not in netplan_config or \
                    'ethernets' not in netplan_config['network']:
                continue

            modify = self._erase_ports_config(netplan_config['network']['ethernets'], ports_config)
            if modify:
                netplan_config = self._netplan_config_with_commented_map(netplan_config)
                content = yaml.dump(netplan_config, Dumper=yaml.RoundTripDumper)
                self._write_config_file(path, content)

    def _get_renderer(self):
        if self.nm_soft_type == LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM:
            return 'NetworkManager'
        else:
            return 'networkd'

    def _config_retain(self, ports_config):
        zstack_yaml = '/etc/netplan/' + self.zstack_config_file_name('.yaml')
        content = self._read_config_file(zstack_yaml)
        if content:
            zstack_config_now = yaml.load(content, Loader=yaml.RoundTripLoader)
        else:
            return None

        if 'network' in zstack_config_now and 'ethernets' in zstack_config_now['network']:
            zstack_ports_retain = zstack_config_now['network']['ethernets']
            mac_map = {config['match']['macaddress']: name for name, config in zstack_ports_retain.items()}
        else:
            return None

        for port_config in ports_config.ports:
            port_name = port_config.port_name
            if port_name in zstack_ports_retain:
                del zstack_ports_retain[port_name]
                continue
            if port_config.mac in mac_map:
                del zstack_ports_retain[mac_map[port_config.mac]]

        # delete leftover configuration
        system_ports = self._get_vm_port_list()
        for port_name in zstack_ports_retain:
            if port_name not in system_ports:
                del zstack_ports_retain[port_name]

        return zstack_ports_retain

    def _create_zstack_config(self, ports_config):
        config = CommentedMap()
        config.yaml_set_start_comment(NetworkConfigPersistBase.config_start_comment())
        network = CommentedMap()
        network["version"] = 2
        network["renderer"] = self._get_renderer()

        ports = CommentedMap()
        for port_config in ports_config.ports:
            port_config_tem = CommentedMap()
            port_config_tem["match"] = {"macaddress": port_config.mac}
            if port_config.mtu:
                port_config_tem["mtu"] = port_config.mtu

            if len(port_config.vmIps) == 0:
                continue

            ip_config = port_config.vmIps[0]
            if ip_config.version != 4:
                raise QgaException(ERROR_CODE_VM_CONFIG_IPV6_NOT_SUPPORT)

            if ip_config.proto == "static":
                port_config_tem["dhcp4"] = "no"
                port_config_tem["addresses"] = [
                    "%s/%s" % (ip_config.ip, ip.get_prefix_len_by_netmask(ip_config.netmask))]
                if ip_config.gateway:
                    port_config_tem["gateway4"] = ip_config.gateway
                if ip_config.dns:
                    port_config_tem["nameservers"] = {"addresses": [address for address in ip_config.dns]}
            else:
                port_config_tem["dhcp4"] = "yes"

            ports[port_config.port_name] = port_config_tem

        ports_config_retain = self._config_retain(ports_config)
        if ports_config_retain:
            ports.update(ports_config_retain)

        network["ethernets"] = ports
        config["network"] = network

        content = yaml.dump(config, Dumper=yaml.RoundTripDumper)
        path = '/etc/netplan/{}'.format(self.zstack_config_file_name('.yaml'))
        self._write_config_file(path, content)

    def persist_ports_config(self, ports_config):
        try:
            backup = False
            files = self.qga.guest_exec_bash_no_exitcode("ls /etc/netplan/*.yaml", exception=False)
            if files:
                files_list = [file for file in files.split('\n') if file != ""]
                self._backup_current_config(files_list)
                backup = True
                self._rectify_current_config(ports_config, files_list)
            self._create_zstack_config(ports_config)
        except Exception as e:
            if backup:
                self._recover_current_config(files_list)
            raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)
        return


class CentosPersistDriver(NetworkConfigPersistBase):
    def ports_config_recover(self, *args, **kwargs):
        pass

    # HWADDR must be specified to prevent interface name changes
    config_temp = '''# Generated by zstack customization engine. Do not edit.
NAME={{ iface_name }}
{% if if_type -%}
TYPE={{ if_type }}
{% endif -%}
HWADDR={{ mac_address }}
DEVICE={{ iface_name }}
{% if mtu -%}
MTU={{ mtu }}
{% endif -%}
BOOTPROTO={{ proto }}
{% if proto == "static" -%}
IPADDR={{ ip_address }}
NETMASK={{ netmask }}
{% if gateway -%}
GATEWAY={{ gateway }}
{% endif -%}
{% if dns -%}
{{ dns }}
{% endif -%}
{% endif -%}
ONBOOT=yes
USERCTL=no
PEERDNS=yes
{% if ipv6_config -%}
{{ ipv6_config }}
{% endif -%}
'''

    def __init__(self, qga, nm_soft_type):
        super(CentosPersistDriver, self).__init__(qga, nm_soft_type)

    def _create_zstack_config(self, ports_config):
        for port_config in ports_config.ports:
            try:
                path = '/etc/sysconfig/network-scripts/ifcfg-{}'.format(port_config.port_name)
                # no need to fall back when writing a new configuration file fails,
                # so there is no need to backup the current configuration
                ipv6_config = None
                content = self._read_config_file(path)
                if content:
                    ipv6_config = '\n'.join([line for line in content.split('\n') if 'IPV6' in line])

                ip4 = port_config.vmIps[0]
                template = Template(self.config_temp)
                dns = '\n'.join(['DNS{}={}'.format(i + 1, addr) for i, addr in enumerate(ip4.dns)]) if ip4.dns else None
                conf = template.render(
                    mac_address=port_config.mac,
                    iface_name=port_config.port_name,
                    mtu=port_config.mtu,
                    dns=dns,
                    ip_address=ip4.ip,
                    netmask=ip4.netmask,
                    gateway=ip4.gateway,
                    proto=ip4.proto,
                    ipv6_config=ipv6_config)
                self._write_config_file(path, conf)

                if port_config.dns:
                    self._dns_config_persist(port_config.dns)
            except Exception as e:
                raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)

    def persist_ports_config(self, ports_config):
        self._create_zstack_config(ports_config)
        return


class UbuntuPersistDriver(NetworkConfigPersistBase):
    config_temp = '''auto {{ port_name }}
iface {{ port_name }} inet {{ proto }}
hwaddress {{ mac_address }}
{% if mtu -%}
mtu {{ mtu }}
{% endif -%}
{% if proto == "static" -%}
address {{ ip_address }}
netmask {{ netmask }}
{% if gateway -%}
gateway {{ gateway }}
{% endif -%}
{% if dns -%}
dns-nameservers {{ dns }}
{% endif -%}
{% endif -%}
'''
    config_file = '/etc/network/interfaces'

    def __init__(self, qga, nm_soft_type):
        super(UbuntuPersistDriver, self).__init__(qga, nm_soft_type)

    def _config_retain(self, ports_config):
        """
        reserved_config:    [], list of original co_get_current_confignfig file lines that need to be kept
        """
        reserved_config = []
        cnt, content = self.qga.guest_file_read(self.config_file)
        if not content:
            return reserved_config

        """
        the ubuntu 'interfaces' file consists of zero or more "iface", "mapping", "auto", "allow-", 
        "source" and "source-directory" stanzas.
        """
        keys = ['auto', 'allow-', 'source', 'source-directory', 'mapping', 'iface']
        new_port_list = [port_config.port_name for port_config in ports_config.ports]
        curr_port_list = self._get_vm_port_list()

        in_iface = False
        for line in content.split('\n'):
            # for configuration comparison
            if line.strip().startswith('#'):
                continue

            info = [x for x in line.strip().split(' ') if x != '']
            key = info[0].strip() if len(info) > 1 else None

            if key in ['source', 'source-directory']:
                continue

            # info[1] == interface name
            if key == 'auto' and \
                    (len(info) < 2 or info[1].strip() in new_port_list or
                     info[1].strip() not in curr_port_list):
                continue

            if key == 'iface' and len(info) == 4:
                port_name = info[1].strip()
                inet = info[2].strip()
                in_iface = True
            elif key in keys:
                in_iface = False

            # keep user-defined configuration, ipv6 configuration,
            if not in_iface or \
                    (port_name in curr_port_list and
                     port_name not in new_port_list or inet != 'inet'):
                reserved_config.append(line)

        return reserved_config

    def _create_zstack_config(self, ports_config):
        zstack_config = ['# {}'.format(self.config_start_comment())]
        reserved_config = self._config_retain(ports_config)
        if reserved_config:
            zstack_config.extend(reserved_config)

        for port_config in ports_config.ports:
            port_name = port_config.port_name
            template = Template(self.config_temp)
            ip4 = port_config.vmIps[0]

            conf = template.render(
                mac_address=port_config.mac,
                port_name=port_name,
                mtu=port_config.mtu,
                dns=' '.join(ip4.dns) if ip4.dns else None,
                ip_address=ip4.ip,
                netmask=ip4.netmask,
                gateway=ip4.gateway,
                proto=ip4.proto)
            zstack_config.extend(conf.split('\n'))

            if port_config.dns:
                self._dns_config_persist(port_config.dns)

        self.qga.guest_file_write(self.config_file, '\n'.join(zstack_config))

    def persist_ports_config(self, ports_config):
        try:
            backup = False
            if self.qga.guest_file_is_exist(self.config_file):
                self._backup_current_config([self.config_file])
                backup = True
            self._create_zstack_config(ports_config)
        except Exception as e:
            if backup:
                self._recover_current_config([self.config_file])
            raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)
        return


def get_virt_domain(vmUuid):
    try:
        @vm_plugin.LibvirtAutoReconnect
        def call_libvirt(conn):
            return conn.lookupByName(vmUuid)

        return call_libvirt(vmUuid)
    except libvirt.libvirtError as e:
        error_code = e.get_error_code()
        if error_code == libvirt.VIR_ERR_NO_DOMAIN:
            return None
        err = 'error happened when looking up vm[uuid:%(uuid)s], libvirt error code: %(error_code)s, %(e)s' % locals()
        raise libvirt.libvirtError(err)


def get_guest_tools_states():
    @vm_plugin.LibvirtAutoReconnect
    def get_domains(conn):
        dom_ids = conn.listDomainsID()
        doms = []
        for dom_id in dom_ids:
            try:
                domain = conn.lookupByID(dom_id)
            except libvirt.libvirtError as ex:
                if ex.get_error_code() == libvirt.VIR_ERR_NO_DOMAIN:
                    continue
                raise ex

            doms.append(domain)
        return doms

    def check_guest_tools_state(domain):
        tools_state = {'state': GUEST_TOOLS_STATE_NOT_RUNNING}
        try:
            qga = Qga(domain)
            if qga.state != Qga.QGA_STATE_RUNNING:
                return tools_state

            _, config = qga.guest_file_read('/usr/local/zstack/guesttools')
            if not config:
                return tools_state

            tools_state['state'] = GUEST_TOOLS_STATE_RUNNING
            version_config = [line for line in config.split('\n') if 'version' in line]
            if version_config:
                tools_state['version'] = version_config[0].split('=')[1].strip()
                tools_state['osType'] = '{} {}'.format(qga.os, qga.os_version) \
                    if all((qga.os != 'Unknown', qga.os_version != 'Unknown')) else 'Unknown'
                if qga.os == VM_OS_WINDOWS:
                    tools_state['platForm'] = 'Windows'
                elif qga.os in VM_OS_LINUX_LIST:
                    tools_state['platForm'] = 'Linux'
                else:
                    tools_state['platForm'] = 'Other'
        except Exception as e:
            logger.error('get guest tools state of vm {} error: {}'.format(domain.name(), e.message))

        return tools_state

    tools_states = {}
    domains = get_domains()
    for domain in domains:
        uuid = domain.name()
        if uuid.startswith("guestfs-"):
            continue
        if uuid == "ZStack Management Node VM":
            continue
        (state, _, _, _, _) = domain.info()
        if state != vm_plugin.Vm.VIR_DOMAIN_RUNNING:
            tools_states[uuid] = {state: GUEST_TOOLS_STATE_NOT_RUNNING}
            continue

        tools_states[uuid] = check_guest_tools_state(domain)
    return tools_states


class VmConfigSyncResponse(kvmagent.AgentResponse):
    def __init__(self):
        super(VmConfigSyncResponse, self).__init__()
        self.errorCode = None


class GetGuestToolsStateResponse(kvmagent.AgentResponse):
    def __init__(self):
        super(GetGuestToolsStateResponse, self).__init__()
        self.states = None


GUEST_TOOLS_STATE_RUNNING = 'Running'
GUEST_TOOLS_STATE_NOT_RUNNING = 'NotRunning'


class VmConfigPlugin(kvmagent.KvmAgent):
    VM_CONFIG_PORTS = "/vm/configsync/ports"
    VM_GUEST_TOOLS_STATE = "/vm/guesttools/state"

    @kvmagent.replyerror
    def vm_config_ports(self, req):
        cmd = jsonobject.loads(req[http.REQUEST_BODY])
        rsp = VmConfigSyncResponse()

        domain = get_virt_domain(cmd.vmUuid)
        if not domain or not domain.isActive():
            rsp.errorCode = ERROR_CODE_VM_NOT_RUNNING
            rsp.success = False
            rsp.error = 'vm {} not running'.format(cmd.vmUuid)
            return jsonobject.dumps(rsp)

        try:
            config_driver = VmConfigDriverBase.get_driver(domain)
            config_driver.config_ports(cmd.portsConfig)
        except QgaException as e:
            rsp.success = False
            rsp.errorCode = e.error_code
            rsp.error = e.message

        return jsonobject.dumps(rsp)

    @kvmagent.replyerror
    def vm_guest_tools_state(self, req):
        rsp = GetGuestToolsStateResponse()
        rsp.states = get_guest_tools_states()
        return jsonobject.dumps(rsp)

    def start(self):
        http_server = kvmagent.get_http_server()
        http_server.register_async_uri(self.VM_CONFIG_PORTS, self.vm_config_ports)
        http_server.register_async_uri(self.VM_GUEST_TOOLS_STATE, self.vm_guest_tools_state)

    def stop(self):
        pass

    def configure(self, config=None):
        pass


if __name__ == "__main__":
    str_config = '''{
    "portsConfig":{
        "ports":[
            {
                "mac":"fa:4a:4e:74:49:00",
                "mtu":1500,
                "vmIps":[
                    {
                        "proto":"dhcp",
                        "version":4,
                        "dns":[
                            "223.5.5.5",
                            "7.7.7.7"
                        ],
                        "ip":"172.25.116.171",
                        "netmask":"255.255.0.0",
                        "gateway": "172.25.0.1"
                    }
                ]
            },
            {
                "mac":"fa:1c:c7:de:4a:01",
                "mtu":1500,
                "vmIps":[
                    {
                        "ip":"10.2.2.219",
                        "netmask":"255.255.255.0",
                        "proto":"static",
                        "version":4
                    }
                ]
            }
        ],
        "vmUUid":"ceede61af61a4268874dbac977a2d0e2"
    },
    "vmUuid":"ceede61af61a4268874dbac977a2d0e2"
}'''

    cmd = jsonobject.loads(str_config)
    rsp = VmConfigSyncResponse()

    domain = get_virt_domain(cmd.vmUuid)
    if not domain:
        print('get vm dom failed.')
        exit(1)
    if not domain.isActive():
        print('vm dom os not active.')
        exit(1)

    try:
        print("init start.")
        config_driver = VmConfigDriverBase.get_driver(domain)
        print("ports_config start.")
        config_driver.config_ports(cmd.portsConfig)
    except QgaException as e:
        print("result error: code=%s, message=%s." % (e.error_code, e.message))
    print('config success')
