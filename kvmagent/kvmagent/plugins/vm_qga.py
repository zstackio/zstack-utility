import os
import time

import libvirt
import libvirt_qemu
import json
import base64
from jinja2 import Template
from ruamel import yaml
from ruamel.yaml.comments import CommentedMap
from zstacklib.utils import log
from zstacklib.utils import linux
from zstacklib.utils import jsonobject
from zstacklib.utils import http
from zstacklib.utils import ip

from kvmagent import kvmagent
from kvmagent.plugins import vm_plugin

VM_OS_LINUX_UBUNTU = "ubuntu"
VM_OS_LINUX_CENTOS = "centos"
VM_OS_LINUX_DEBIAN = "debian"
VM_OS_LINUX_KYLIN = "kylin"
VM_OS_LINUX_UOS = "uos"
VM_OS_WINDOWS = "mswindows"
VM_OS_LINUX_LIST = [VM_OS_LINUX_UBUNTU, VM_OS_LINUX_CENTOS, VM_OS_LINUX_DEBIAN, VM_OS_LINUX_KYLIN, VM_OS_LINUX_UOS]

ERROR_CODE_VM_NOT_RUNNING = 'VM_NOT_RUNNING'
ERROR_CODE_VM_CONFIG_IPV6_NOT_SUPPORT = 'VM_CONFIG_IPV6_NOT_SUPPORT'
ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_IP = 'VM_CONFIG_NOT_EFFECTIVE_IP'
ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_GW = 'VM_CONFIG_NOT_EFFECTIVE_GW'
ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_MTU = 'VM_CONFIG_NOT_EFFECTIVE_MTU'
ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_DNS = 'VM_CONFIG_NOT_EFFECTIVE_DNS'
ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED = 'VM_CONFIG_PERSISTENCE_FAILED'
ERROR_CODE_VM_CONFIG_INTERNAL = 'VM_CONFIG_INTERNAL'
ERROR_CODE_QGA_NOT_RUNNING = 'QGA_NOT_RUNNING'
ERROR_CODE_QGA_OS_NOT_SUPPORT = 'QGA_OS_NOT_SUPPORT'
ERROR_CODE_QGA_COMMAND_IS_DISABLED = 'QGA_COMMAND_IS_DISABLED'
ERROR_CODE_QGA_VERSION_TOO_LOWER = 'QGA_VERSION_TOO_LOWER'
ERROR_CODE_QGA_COMMAND_ERROR = 'QGA_COMMAND_EXEC_ERROR'
ERROR_CODE_QGA_RETURN_VALUE_ERROR = 'QGA_RETURN_VALUE_ERROR'

VM_CONFIG_SYNC_OS_VERSION_SUPPORT = {
    VM_OS_LINUX_UBUNTU: ("16", "18", "20", "21", "22"),
    VM_OS_LINUX_CENTOS: ("6", "7", "8"),
    VM_OS_LINUX_KYLIN: ("v10",),
    VM_OS_LINUX_UOS: ("20",)
}

ZSTACK_START_COMMENT = "#Generated by ZStack customization engine. Do not edit."

logger = log.get_logger(__name__)


class Qga(object):
    QGA_STATE_UNKNOWN = "Unknown"
    QGA_STATE_RUNNING = "Running"
    QGA_STATE_NOT_RUNNING = "NotRunning"

    def __init__(self, domain):
        self.domain = domain
        self.vm_uuid = domain.name()
        self.state = Qga.QGA_STATE_NOT_RUNNING
        self.version = None
        self.supported_commands = {}
        self.os = None
        self.os_version = None
        self.os_id_like = None
        self.qga_init()
        self.qga_debug()

    def qga_debug(self):
        logger.debug('qga info: vm_uuid: %s\n state:%s\n version:%s\n os:%s\n os_version:%s\n supported_commands:%s' \
                     % (self.vm_uuid, self.state, self.version, self.os, self.os_version, self.supported_commands))

    def call_qga_command(self, command, args=None, timeout=3):
        """
        Execute QEMU-GA command and return result as dict or None on error

        command   the command to execute (string)
        args      arguments to the command (dict) or None
        :rtype: dict
        """
        if self.supported_commands:
            if command not in self.supported_commands:
                raise QgaException(ERROR_CODE_QGA_VERSION_TOO_LOWER, 'qga command {} not support, qga version is {}'
                                   .format(command, self.version))
            if not self.supported_commands[command]:
                raise QgaException(ERROR_CODE_QGA_COMMAND_IS_DISABLED, 'qga command {} has been disabled'
                                   .format(command))

        cmd = {'execute': command}
        if args:
            if 'buf-b64' in args:
                args['buf-b64'] = base64.b64encode(args['buf-b64'])
            cmd['arguments'] = args
        cmd = json.dumps(cmd)
        try:
            ret = libvirt_qemu.qemuAgentCommand(self.domain, cmd,
                                                timeout, 0)
        except libvirt.libvirtError as e:
            if 'error' in e.message:
                message = 'exec qga command[{}] args[{}] error: {}'.format(cmd, args, e.message)
                raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR, message)

        try:
            parsed = json.loads(ret)
        except ValueError:
            raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR,
                               'qga command return value parsing error:{}'.format(ret))

        if 'return' not in parsed:
            raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR,
                               'qga command return value format error:{}'.format(ret))

        parsedRet = parsed['return']
        if isinstance(parsedRet, dict):
            if 'out-data' in parsedRet:
                parsedRet['out-data'] = base64.b64decode(parsedRet['out-data'])  # .decode("GB2312")
            if 'err-data' in parsedRet:
                parsedRet['err-data'] = base64.b64decode(parsedRet['err-data'])  # .decode("GB2312")
            if 'buf-b64' in parsedRet:
                parsedRet['buf-b64'] = base64.b64decode(parsedRet['buf-b64'])

        return parsedRet

    def guest_exec_status(self, pid):
        return self.call_qga_command("guest-exec-status", args={'pid': pid})

    def guest_exec(self, args):
        return self.call_qga_command("guest-exec", args=args)

    def guest_exec_bash_no_exitcode(self, cmd, exception=True, output=True, wait=0.1):
        exitcode, ret_data = self.guest_exec_bash(cmd, output, wait)
        if exitcode != 0:
            if exception:
                raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR, 'cmd {}, exitcode {}, ret {}'
                                   .format(cmd, exitcode, ret_data))
            return None
        return ret_data

    def guest_exec_bash(self, cmd, output=True, wait=0.1):

        ret = self.guest_exec(
            {"path": "bash", "arg": ["-c", cmd], "capture-output": output})
        if ret and "pid" in ret:
            pid = ret["pid"]
        else:
            raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR,
                               'qga exec cmd {} failed for vm {}'.format(cmd, self.vm_uuid))

        if not output:
            return None

        time.sleep(wait)
        ret = self.guest_exec_status(pid)
        if not ret or 'exited' not in ret:
            raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR,
                               'qga exec cmd {} failed for vm {}'.format(cmd, self.vm_uuid))

        # format: {"return":{"exited":false}}
        if not ret['exited']:
            raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR,
                               'qga exec cmd {} timeout for vm {}'.format(cmd, self.vm_uuid))

        exit_code = ret.get('exitcode')
        ret_data = None
        if 'out-data' in ret:
            ret_data = ret['out-data']
        elif 'err-data' in ret:
            ret_data = ret['err-data']
        return exit_code, ret_data

    def guest_info(self):
        return self.call_qga_command("guest-info")

    def guest_ping(self):
        ret = self.call_qga_command("guest-ping")
        return ret

    def guest_agent_available(self):
        try:
            ret = self.guest_ping()
            if ret is None:
                return False
            return True
        except:
            return False

    def guest_exec_get_os_info(self):
        ret = self.call_qga_command("guest-get-osinfo")
        if ret and "id" in ret and "version-id" in ret:
            vm_os = ret["id"].lower()
            version = ret["version-id"].lower()
            if vm_os == VM_OS_LINUX_UBUNTU:
                version = version.split(".")[0]
            return vm_os, version
        raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR,
                           'get vm %s os info failed' % self.vm_uuid)

    def guest_get_os_id_like(self):
        ret = self.guest_exec_bash_no_exitcode('cat /etc/os-release | grep ID_LIKE', exception=False)
        if ret:
            info = ret.split("=")
            return info[1] if len(info) > 1 else None
        return None

    def guest_get_os_info(self):
        ret = self.guest_exec_bash_no_exitcode('cat /etc/os-release')
        if not ret:
            raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR, 'get os info failed')

        lines = [line for line in ret.split('\n') if line != ""]
        config = {}
        for line in lines:
            if line.startswith('#'):
                continue

            info = line.split('=')
            if len(info) != 2:
                continue
            config[info[0].strip()] = info[1].strip().strip('"')

        vm_os = config.get('ID')
        version = config.get('VERSION_ID')
        if vm_os and version and vm_os == VM_OS_LINUX_UBUNTU:
            version = version.split(".")[0]

        return vm_os, version, config.get('ID_LIKE')

    def qga_init(self):
        if not self.domain.isActive():
            self.state = Qga.QGA_STATE_NOT_RUNNING
            return

        self.state = Qga.QGA_STATE_RUNNING if self.guest_agent_available() else Qga.QGA_STATE_NOT_RUNNING
        if self.state != Qga.QGA_STATE_RUNNING:
            return

        ret = self.guest_info()
        if ret:
            self.version = ret["version"]
            supported_commands = ret["supported_commands"]
            self.supported_commands = {cmd["name"]: cmd["enabled"] for cmd in supported_commands}

        try:
            if 'guest-get-osinfo' in self.supported_commands and \
                    self.supported_commands['guest-get-osinfo']:
                self.os, self.os_version = self.guest_exec_get_os_info()
                self.os_id_like = self.guest_get_os_id_like()
            else:
                self.os, self.os_version, self.os_id_like = self.guest_get_os_info()
        except QgaException as e:
            if e.error_code in (ERROR_CODE_QGA_COMMAND_IS_DISABLED, ERROR_CODE_QGA_VERSION_TOO_LOWER):
                self.os, self.os_version, self.os_id_like = 'Unknown', 'Unknown', 'Unknown'
            else:
                raise e

    def guest_get_hostname(self):
        ret = self.call_qga_command("guest-get-host-name")
        if ret and 'host-name' in ret:
            return ret['host-name']
        else:
            raise QgaException(ERROR_CODE_QGA_RETURN_VALUE_ERROR, 'qga get hostname failed for vm %s' % self.vm_uuid)

    def guest_file_open(self, path, create=False):
        if create:
            mode = "w+"
        else:
            mode = "r"
        return self.call_qga_command("guest-file-open", args={"path": path, "mode": mode})

    def guest_file_close(self, handle):
        return self.call_qga_command("guest-file-close", args={"handle": handle})

    def guest_file_flush(self, handle):
        return self.call_qga_command("guest-file-flush", args={"handle": handle})

    def guest_file_read(self, path, not_exist_exception=False):
        try:
            handle = self.call_qga_command("guest-file-open", args={"path": path, "mode": 'r'})
        except Exception as e:
            if 'No such file' in e.message and not not_exist_exception:
                return 0, None
            raise e

        try:
            ret = self.call_qga_command("guest-file-read", args={"handle": handle})
        except Exception as e:
            self.guest_file_close(handle)
            raise e

        self.guest_file_close(handle)
        return ret.get('count'), ret.get('buf-b64')

    def guest_file_is_exist(self, path):
        try:
            handle = self.call_qga_command("guest-file-open", args={"path": path, "mode": 'r'})
        except Exception as e:
            if 'No such file' in e.message:
                return False
            else:
                raise e

        self.guest_file_close(handle)
        return True

    def guest_file_write(self, path, contents):
        handle = self.guest_file_open(path, True)
        try:
            ret = self.call_qga_command("guest-file-write", args={"handle": handle, "buf-b64": contents})
        except Exception as e:
            self.guest_file_close(handle)
            raise e
        self.guest_file_close(handle)
        return ret.get('count')


class VmConfigDriverBase(object):
    def __init__(self, qga):
        self.qga = qga
        self.driver_name = 'base'
        self.nm_soft_type = None
        self.nm_driver = None
        self.config_persist_driver = None

    def _get_nm_soft_type(self):
        if self.qga.guest_exec_bash_no_exitcode("ps -C systemd-networkd | grep systemd-network", exception=False):
            return LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_SYSTEMD
        elif self.qga.guest_exec_bash_no_exitcode("ps -C NetworkManager | grep NetworkManager", exception=False):
            return LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM

        return LinuxVmConfigDriverBase.LINUX_NM_TYPE_NONE

    @staticmethod
    def _set_mn_driver(func):
        def set_driver(self, config):
            if not self.nm_soft_type:
                self.nm_soft_type = self._get_nm_soft_type()
            if not self.nm_driver:
                self.nm_driver = self.get_nm_driver()
            if not self.config_persist_driver:
                self.config_persist_driver = self.get_config_persist_driver()
            logger.debug('_set_mn_driver, nm_soft_type={}, nm_driver={}, config_persist_driver={}'
                         .format(self.nm_soft_type, self.nm_driver.__class__.__name__,
                                 self.config_persist_driver.__class__.__name__))
            return func(self, config)

        return set_driver

    def get_nm_driver(self):
        qga = self.qga
        if qga.guest_exec_bash_no_exitcode("which netplan", exception=False) and \
                self.nm_soft_type in (
                LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM, LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_SYSTEMD):
            return LinuxNmNetplanDriver(qga)
        if self.nm_soft_type == LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM:
            if self.qga.os in [VM_OS_LINUX_UBUNTU, VM_OS_LINUX_DEBIAN, VM_OS_LINUX_UOS]:
                if self.qga.guest_exec_bash_no_exitcode(
                        "cat /etc/NetworkManager/NetworkManager.conf | grep '^[ ]*managed[ ]*=[ ]*true'",
                        exception=False):
                    # return LinuxNmIfUpDownDriver(qga)
                    return LinuxNmNmcliDriver(qga, True)
            else:
                return LinuxNmNmcliDriver(qga, False)

        return LinuxNmIprouteDriver(qga)

    def get_config_persist_driver(self):
        if self.nm_driver.driver_type == VmNetworkManagerBase.VM_NM_DRIVER_NETPLAN:
            return NetplanPersistDriver(self.qga, self.nm_soft_type)
        elif self.driver_name == "centos":
            return CentosPersistDriver(self.qga, self.nm_soft_type)
        elif self.driver_name == "ubuntu":
            return UbuntuPersistDriver(self.qga, self.nm_soft_type)
        else:
            raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL,
                               'not support vm_config_driver %s nm_driver %s' % (self.driver_name, self.nm_driver))

    @staticmethod
    def get_driver(domain):
        qga = Qga(domain)
        if qga.state != Qga.QGA_STATE_RUNNING:
            raise QgaException(ERROR_CODE_QGA_NOT_RUNNING, 'qga state not running for vm {}'.format(domain.name()))
        if qga.os not in VM_CONFIG_SYNC_OS_VERSION_SUPPORT.keys() or \
                qga.os_version not in VM_CONFIG_SYNC_OS_VERSION_SUPPORT[qga.os]:
            raise QgaException(ERROR_CODE_QGA_OS_NOT_SUPPORT, 'not support for {}{}'.format(qga.os, qga.os_version))

        if qga.os in (VM_OS_LINUX_CENTOS, VM_OS_LINUX_KYLIN):
            vm_config_driver = CentOSVmConfigDriver(qga)
        elif qga.os == VM_OS_LINUX_UOS and qga.os_id_like and 'fedora' in qga.os_id_like:
            vm_config_driver = CentOSVmConfigDriver(qga)
        elif qga.os in (VM_OS_LINUX_UBUNTU, VM_OS_LINUX_UOS):
            vm_config_driver = UbuntuVmConfigDriver(qga)
        return vm_config_driver

    def ports_config(self, *args, **kwargs):
        raise NotImplementedError()


class LinuxVmConfigDriverBase(VmConfigDriverBase):
    LINUX_NM_SOFT_TYPE_NM = "network_manager"
    LINUX_NM_SOFT_TYPE_SYSTEMD = "systemd"
    LINUX_NM_TYPE_NONE = "none"

    def __init__(self, qga):
        VmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'linux'

    def _get_phy_interfaces(self):
        ret = self.qga.guest_exec_bash_no_exitcode("ls -l /sys/class/net/*/device", exception=False)
        if not ret:
            return None
        '''
        the format of "ret" like this:
        lrwxrwxrwx 1 root root 0 Nov 21 18:04 /sys/class/net/enp101s0f0/device -> ../../../0000:65:00.0
        '''
        phy_ports = [line.split("/")[4] for line in ret.split('\n') if len(line.split("/")) > 5]
        path_list = ["/sys/class/net/%s/address" % port for port in phy_ports]
        ret = self.qga.guest_exec_bash_no_exitcode("cat " + " ".join(path_list))
        if not ret:
            return None

        mac_list = [mac for mac in ret.split('\n') if ':' in mac]
        if len(phy_ports) != len(mac_list):
            raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL, 'get vm physical interface failed')

        return dict(zip(mac_list, phy_ports))

    def _set_port_name_for_config(self, ports_config):
        phy_ports = self._get_phy_interfaces()

        for port_config in ports_config.ports:
            if port_config.mac not in phy_ports:
                raise QgaException(ERROR_CODE_VM_CONFIG_INTERNAL,
                                   'get vm physical with mac {} failed'.format(port_config.mac))
            setattr(port_config, 'port_name', phy_ports[port_config.mac])

    @VmConfigDriverBase._set_mn_driver
    def ports_config(self, ports_config):
        vm_uuid = self.qga.vm_uuid
        self._set_port_name_for_config(ports_config)
        # persist config file
        changed_nic = self.config_persist_driver.ports_config_persist(ports_config)
        logger.debug('vm[{}] port config persistence success, changed_nic{}.'.format(vm_uuid, changed_nic))

        # reload config file
        self.nm_driver.ports_config_reload(ports_config, changed_nic)
        logger.debug('vm[{}] port config reload success.'.format(vm_uuid))

        # check whether the configuration has taken effect
        self.nm_driver.ports_config_checking(ports_config, changed_nic)
        logger.debug('vm[{}] port config checking success.'.format(vm_uuid))


class WindowsVmConfigDriverBase(VmConfigDriverBase):
    def __init__(self, qga):
        VmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'linux'

    @VmConfigDriverBase._set_mn_driver
    def ports_config(self, ports_config):
        raise QgaException(ERROR_CODE_QGA_OS_NOT_SUPPORT, 'not support windows')


class CentOSVmConfigDriver(LinuxVmConfigDriverBase):

    def __init__(self, qga):
        LinuxVmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'centos'


class UbuntuVmConfigDriver(LinuxVmConfigDriverBase):
    def __init__(self, qga):
        LinuxVmConfigDriverBase.__init__(self, qga)
        self.driver_name = 'ubuntu'


'''
    class VmNetworkManagerBase: realize the effective way of vm network configuration
'''


class VmNetworkManagerBase(object):
    VM_NM_DRIVER_NETPLAN = 'netplan'
    VM_NM_DRIVER_NMCLI = 'nmcli'
    VM_NM_DRIVER_IFUPDPWN = 'ifupdown'
    VM_NM_DRIVER_IPROUTE = 'iproute'

    def __init__(self, qga):
        self.driver_type = "base"
        self.qga = qga

    def ports_config_reload(self, *args, **kwargs):
        raise NotImplementedError()


class LinuxNmDriverBase(VmNetworkManagerBase):
    def __init__(self, qga):
        super(LinuxNmDriverBase, self).__init__(qga)
        self.driver_type = "linux_base"

    def ports_config_reload(self, *args, **kwargs):
        raise NotImplementedError()

    @linux.retry(times=5, sleep_time=6)
    def ports_config_checking(self, ports_config, changed_nic):

        bash_cmd = '''#!/bin/bash
if [[ $(ip addr ls dev {{ port_name }} | grep {{ ip_address }}/{{ prefix_len }}) == "" ]];then
    exit 11
fi
gw_config=""
{%- if gateway %}
gw_config={{ gateway }}
if [[ $(ip route | grep "default via {{ gateway }} dev {{ port_name }}") == "" ]];then
    exit 21
fi
{%- endif %}
{%- if mtu %}
if [[ $(ip link ls dev {{ port_name }} | grep 'mtu {{ mtu }}') == "" ]];then
    exit 31
fi
{%- endif %}
{%- if dns %}
    cur_dns=$(cat /etc/resolv.conf | grep '^nameserver' | awk -F ' ' '{print $2; exit}')
    if [[ cur_dns == "127.0.0.53" && $(which resolvectl) != "" ]]; then
        cur_dns=$(resolvectl dns {{ port_name }} | awk -F ':' '{ print $2}')
    fi
    cur_dns=`echo cur_dns`
    if [[ cur_dns != "{{ dns }}" ]]; then
        ### backup dns checking
        if [[ $gw_config == "" && $(cat /etc/resolv.conf | grep {{ dns }}) != "" ]]; then
            exit 0
        fi
        exit 41
    fi
{%- endif %}

exit 0'''
        for port_config in ports_config.ports:
            if port_config.port_name not in changed_nic:
                continue

            template = Template(bash_cmd)
            ip_config = port_config.vmIps[0]
            conf = template.render(port_name=port_config.port_name,
                                   ip_address=ip_config.ip,
                                   prefix_len=ip.get_prefix_len_by_netmask(ip_config.netmask),
                                   gateway=ip_config.gateway,
                                   mtu=port_config.mtu,
                                   dns=ip_config.dns)

            exitcode, ret_data = self.qga.guest_exec_bash(conf)
            item = ''
            if exitcode == 0:
                continue
            elif exitcode == 11:
                err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_IP
                item = 'ip address'
            elif exitcode == 21:
                err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_GW
                item = 'gateway'
            elif exitcode == 31:
                err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_MTU
                item = 'mtu'
            elif exitcode == 41:
                err_code = ERROR_CODE_VM_CONFIG_NOT_EFFECTIVE_DNS
                item = 'dns'
            else:
                err_code = ERROR_CODE_QGA_COMMAND_ERROR
            raise QgaException(err_code, 'vm {} port {} {} not effective, ret {}'.format(
                self.qga.vm_uuid, port_config.port_name, item, ret_data))


class LinuxNmNmcliDriver(LinuxNmDriverBase):
    def __init__(self, qga, accurate=False):
        super(LinuxNmNmcliDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_NMCLI
        self.accurate = accurate

    def ports_config_reload(self, ports_config, changed_nic):
        if len(changed_nic) == 0:
            return

        # 'nmcli conn reload' working normally in centos, but abnormally in ubuntu
        if self.accurate:
            bash_cmd = '''#!/bin/bash
ports_list=({ports_list})
config_list=({config_list})
#for port_name in ${{ports_list[@]}}
#do
for (( i = 0 ; i < ${{#ports_list[@]}} ; i++ ))
do
    port_name=${{ports_list[$i]}}

    uuid=$(nmcli -m tabular -t -f GENERAL.CON-UUID device show $port_name)
    if [[ $uuid == "" ]];then
        nmcli device -w 1 connect $port_name 2> /dev/null
        uuid=$(nmcli -m tabular -t -f GENERAL.CON-UUID device show $port_name)
    fi

    if [[ $uuid == "" ]];then
        continue
    fi

    config=${{config_list[$i]}}
    echo "nmcli -w 1 conn modify ${{uuid}} ${{config}}"
    eval nmcli -w 1 conn modify $uuid $config 2>/root/111
    nmcli -w 1 conn down $uuid 
    nmcli -w 1 conn up $uuid
done
'''
            ports = []
            configs = []
            for port_config in ports_config.ports:
                if port_config.port_name not in changed_nic:
                    continue
                config = []
                ip_config = port_config.vmIps[0]
                config.append('ipv4.method {}'.format('auto' if ip_config.proto == 'dhcp' else 'manual'))
                if ip_config.proto == 'static':
                    config.append('ipv4.address {}/{}'.format(ip_config.ip,
                                                              ip.get_prefix_len_by_netmask(ip_config.netmask)))
                    if ip_config.gateway:
                        config.append('ipv4.gateway {}'.format(ip_config.gateway))
                    else:
                        config.append("ipv4.gateway ''")

                    if ip_config.dns:
                        config.append('ipv4.dns {}'.format(ip_config.dns))
                    else:
                        config.append("ipv4.dns ''")

                    if port_config.mtu:
                        config.append('802-3-ethernet.mtu {}'.format(port_config.mtu))
                    else:
                        config.append('802-3-ethernet.mtu auto')
                else:
                    config.append("ipv4.address ''")
                    config.append("ipv4.gateway ''")
                    config.append("ipv4.dns ''")
                    config.append('802-3-ethernet.mtu auto')

                ports.append(port_config.port_name)
                configs.append('"{}"'.format(' '.join(config)))
            ports_list = ' '.join(ports)
            config_list = ' '.join(configs)
            self.qga.guest_exec_bash(bash_cmd.format(ports_list=ports_list, config_list=config_list), wait=1)
        else:
            bash_cmd = ['nmcli conn reload 2> /dev/null']
            for port_name in changed_nic:
                bash_cmd.append('nmcli conn down {} 2> /dev/null; nmcli conn up {} 2> /dev/null'
                                .format(port_name, port_name))
        self.qga.guest_exec_bash(';'.join(bash_cmd), False)


class LinuxNmNetplanDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmNetplanDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_NETPLAN

    def ports_config_reload(self, ports_config, changed_nic):
        if len(changed_nic) == 0:
            return

        self.qga.guest_exec_bash('netplan apply 2> /dev/null', False)


class LinuxNmIfUpDownDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmIfUpDownDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_IFUPDPWN

    def ports_config_reload(self, ports_config, changed_nic):
        if len(changed_nic) == 0:
            return
        bash_cmd = '''#!/bin/bash
ports=({ports_list})
ports_dns=({dns_list})
#for port_name in ${{ports[@]}}
for (( i = 0 ; i < ${{#ports[@]}} ; i++ ))
do
    port_name=${{ports[$i]}}
    port_dns=${{ports_dns[$i]}}
    nm=0
    if [[ $(ps -C NetworkManager | grep "NetworkManager") != "" ]];then
        nmcli -w 1 device disconnect $port_name 2> /dev/null
        nm=1
    fi
    ip -4 address flush dev $port_name 2> /dev/null
    ifdown $port_name 2> /dev/null
    ifup $port_name 2> /dev/null

    if [[ $port_dns != "none" ]]; then
        dns_info=(${port_dns//:/ }) 
        new_dns=${{dns_info[0]}}
        role=${{dns_info[1]}}

        dns1=`sed '/${{new_dns}}/d' /etc/resolv.conf | grep '^[ ]*nameserver'`
        if [[ $role == 'master' ]]; then
            dns_config="{{ zstack_comment }}\n\nnameserver ${{new_dns}}\n$dns1"
        else
            dns_config="{{ zstack_comment }}\n\n$dns1\nnameserver ${{new_dns}}"
        fi
        echo -e "${dns_config}" > /etc/resolv.conf
    fi
done
'''
        ports_list = []
        dns_list = []
        for port_config in ports_config.ports:
            if port_config.port_name not in changed_nic:
                continue
            ports_list.append(port_config.port_name)
            ip_config = port_config.vmIps[0]
            role = 'master' if ip_config.gateway else 'backup'
            dns_list.append('{}:{}'.format(ip_config.dns, role) if ip_config and ip_config.dns else 'none')

        self.qga.guest_exec_bash(bash_cmd.format(ports_list=ports_list, dns_list=dns_list), wait=1)


class LinuxNmIprouteDriver(LinuxNmDriverBase):

    def __init__(self, qga):
        super(LinuxNmIprouteDriver, self).__init__(qga)
        self.driver_type = VmNetworkManagerBase.VM_NM_DRIVER_IPROUTE

    def ports_config_reload(self, ports_config, changed_nic):
        if len(changed_nic) == 0:
            return

        bash_cmd = '''#!/bin/bash
### stop nm connection
if [[ $(ps -C NetworkManager | grep NetworkManager") != "" ]];then
    nmcli -w 1 device disconnect {{ port_name }} 2>/dev/null
fi

# stop dhclient
cur_dhclient=$(ps aux | grep dhclient | grep -v 'bash -c' | grep {{ port_name }})
pf=""
lf=""
if [[ cur_dhclient != "" ]]; then
    pf=$(echo $cur_dhclient | awk -F '-pf' '{print $2}' | awk -F ' ' '{print $1}')
    if [[ $pf != "" ]]; then
        pf="-pf "$pf
    fi
    lf=$(echo $cur_dhclient | awk -F '-lf' '{print $2}' | awk -F ' ' '{print $1}')
    if [[ $lf != "" ]]; then
        lf="-lf "$lf
    fi

    $(which dhclient) -r {{ port_name }} $pf 2> /dev/null
fi

{% if proto == "static" -%}
    if [[ $(ip addr ls dev {{ port_name }} | grep {{ ip_address }}/{{ prefix_len }}) == "" ]];then
        ip -4 address flush dev {{ port_name }}
        ip -4 address add {{ ip_address }}/{{ prefix_len }} dev {{ port_name }}
    fi
    master=0
    {%- if gateway %}
        master=1
        if [[ $(ip route | grep "default via {{ gateway }} dev {{ port_name }}") == "" ]];then
            ip route add default via {{ gateway }} dev {{ port_name }}
        fi
    {%- endif %}
    {%- if mtu %}
        ip link set mtu {{ mtu }} dev {{ port_name }}
    {%- endif %}
{% else -%}
$(which dhclient) -1 -v  $pf $lf -I {{ port_name }} 2> /dev/null
{%- endif %}
'''
        dns_list = []
        dns_mod = False
        for port_config in ports_config.ports:
            ip_config = port_config.vmIps[0]
            if ip_config.dns:
                dns_list.insert(0, ip_config.dns) if ip_config.gateway else dns_list.append(ip_config.dns)

            if port_config.port_name not in changed_nic:
                continue
            template = Template(bash_cmd)
            conf = template.render(port_name=port_config.port_name,
                                   ip_address=ip_config.ip,
                                   proto=ip_config.proto,
                                   prefix_len=ip.get_prefix_len_by_netmask(ip_config.netmask),
                                   gateway=ip_config.gateway,
                                   mtu=port_config.mtu)
            self.qga.guest_exec_bash(conf, False, wait=5)
            if ip_config.dns and ip_config.proto == 'static':
                dns_mod = True

        if dns_mod:
            bash_cmd = '''#!/bin/bash

ports_dns=({dns_list})
cur_dns=`cat /etc/resolv.conf`
delete=""
for dns in ${{ports_dns[@]}}
do
    delete=$delete"/${{dns}}/d;"
    add=$add"\nnameserver ${{dns}}"
done
dns1=`eval sed '${{delete}}' /etc/resolv.conf | grep '^[ ]*nameserver'`
dns_config="{ zstack_comment }\n${{add}}\n${{dns1}}"
echo -e "${{dns_config}}" > /etc/resolv.conf
'''
            self.qga.guest_exec_bash(bash_cmd.format(dns_list=dns_list, zstack_comment=ZSTACK_START_COMMENT), False)


'''
    class NetworkConfigPersistBase: for vm networking configuration persistent
'''


class NetworkConfigPersistBase(object):
    def __init__(self, qga, nm_soft_type):
        self.qga = qga
        self.nm_soft_type = nm_soft_type

    @staticmethod
    def zstack_config_file_name(suffix):
        return "99-zstack-net-cfg" + suffix

    @staticmethod
    def config_backup_name(file_name):
        return file_name + ".ZStackBackup"

    @staticmethod
    def config_start_comment():
        return "#Generated by ZStack customization engine. Do not edit."

    def write_config_file(self, path, content):
        ret = self.qga.guest_file_write(path, content)
        if ret != len(content):
            raise QgaException(ERROR_CODE_QGA_COMMAND_ERROR, 'config file write error')

    def read_config_file(self, path):
        _, content = self.qga.guest_file_read(path)
        return content

    def backup_current_config(self, files_list):
        for path in files_list:
            self.qga.guest_exec_bash('\\cp %s %s' % (path, self.config_backup_name(path)), False)

    def recover_current_config(self, files_list):
        for path in files_list:
            self.qga.guest_exec_bash('\\cp %s %s' % (self.config_backup_name(path), path), False)

    def dns_config_persist(self, dns):
        if dns:
            content = '{}\n\nnameserver {}'.format(self.config_start_comment(), dns)
            self.write_config_file('/etc/resolv.conf', content)

    def ports_config_persist(self, *args, **kwargs):
        raise NotImplementedError()


class NetplanPersistDriver(NetworkConfigPersistBase):
    # Not used, but reserved for reference
    config_temp = '''# Generated by zstack customization engine.
network:
  version: 2
  renderer: networkd
  ethernets:
    {{ iface_name }}:
      match:
        macaddress: {{ mac_address }}
      {% if mtu -%}
      mtu: {{ mtu }}
      {%- endif %}
      {% if proto == "static" -%}
      dhcp4: no
      addresses: [ {{ ip_address }}/{{ prefix_size }} ]
      {% if gateway -%}
      gateway4: {{ gateway }}
      {%- endif %}
      {% if dns -%}
      nameservers:
        addresses: [ {{ dns }} ]
      {%- endif %}
      {%- else %}
      dhcp4: yes
      {%- endif %}
'''

    def __init__(self, qga, nm_soft_type):
        super(NetplanPersistDriver, self).__init__(qga, nm_soft_type)

    @staticmethod
    def _netplan_config_with_commented_map(netplan_config):
        """
         map to commented_map, for the configuration to be written in order
        """
        config = CommentedMap()
        config.yaml_set_start_comment(NetworkConfigPersistBase.config_start_comment())
        network_commented = CommentedMap()
        network_config = netplan_config['network']
        if 'version' in network_config:
            network_commented['version'] = network_config['version']
            del network_config['version']
        if 'renderer' in network_config:
            network_commented['renderer'] = network_config['renderer']
            del network_config['renderer']
        if 'ethernets' in network_config:
            network_commented['ethernets'] = network_config['ethernets']
            del network_config['ethernets']
        for key, value in network_config.items():
            network_commented[key] = value
        config['network'] = network_commented
        del netplan_config['network']
        for key, value in netplan_config.items():
            config[key] = value
        return config

    @staticmethod
    def _erase_ports_config(netplan_config, ports_config):
        """
        Delete the configuration that will be overwritten and keep other configurations
        """
        modify = False
        for port_config in ports_config.ports:
            port_name = port_config.port_name
            if port_name not in netplan_config:
                continue

            if len(port_config.vmIps) == 0:
                continue

            netplan_port_config = netplan_config[port_name]
            ip_config = port_config.vmIps[0]
            if ip_config.version == 6:
                raise QgaException(ERROR_CODE_VM_CONFIG_IPV6_NOT_SUPPORT)

            if 'dhcp4' in netplan_port_config:
                del netplan_port_config['dhcp4']
                modify = True
            if 'gateway4' in netplan_port_config:
                del netplan_port_config['gateway4']
                modify = True
            if 'addresses' in netplan_port_config:
                ipv6_list = [ip for ip in netplan_port_config['addresses'] if not ip.is_ipv4(ip)]
                if len(ipv6_list) != len(netplan_port_config['addresses']):
                    netplan_port_config['addresses'] = ipv6_list
                    modify = True
            if ip_config.dns and 'nameservers' in netplan_port_config:
                del netplan_port_config['nameservers']
                modify = True
        return modify

    def _rectify_current_config(self, ports_config, files_list):
        """
        Delete the configuration that will be overwritten and keep other configurations.
        otherwise there will be a configuration conflict
        """
        for path in files_list:
            file_info = os.path.split(path)
            # skip zstack config file
            if len(file_info) == 2 and \
                    file_info[1] == self.zstack_config_file_name('yaml'):
                continue

            content = self.read_config_file(path)
            if not content:
                continue
            netplan_config = yaml.load(content, Loader=yaml.RoundTripLoader)
            if 'network' not in netplan_config or \
                    'ethernets' in netplan_config['network']:
                continue

            modify = self._erase_ports_config(netplan_config['network']['ethernets'], ports_config)
            if modify:
                netplan_config = self._netplan_config_with_commented_map(netplan_config)
                content = yaml.dump(netplan_config, Dumper=yaml.RoundTripDumper)
                self.write_config_file(path, content)

    def _get_renderer(self):
        if self.nm_soft_type == LinuxVmConfigDriverBase.LINUX_NM_SOFT_TYPE_NM:
            return 'NetworkManager'
        else:
            return 'networkd'

    def _create_zstack_config(self, ports_config):
        config = CommentedMap()
        config.yaml_set_start_comment(NetworkConfigPersistBase.config_start_comment())
        network = CommentedMap()
        network["version"] = 2
        network["renderer"] = self._get_renderer()

        ports = CommentedMap()
        for port_config in ports_config.ports:
            port_config_tem = CommentedMap()
            port_config_tem["match"] = {"macaddress": port_config.mac}
            if port_config.mtu:
                port_config_tem["mtu"] = port_config.mtu

            if len(port_config.vmIps) == 0:
                continue

            ip_config = port_config.vmIps[0]
            if ip_config.version != 4:
                raise QgaException(ERROR_CODE_VM_CONFIG_IPV6_NOT_SUPPORT)

            if ip_config.proto == "static":
                port_config_tem["dhcp4"] = "no"
                port_config_tem["addresses"] = [
                    "%s/%s" % (ip_config.ip, ip.get_prefix_len_by_netmask(ip_config.netmask))]
                port_config_tem["gateway4"] = ip_config.gateway
                if ip_config.dns:
                    port_config_tem["nameservers"] = {"addresses": ["114.114.114.114"]}
            else:
                port_config_tem["dhcp4"] = "yes"

            ports[port_config.port_name] = port_config_tem
        network["ethernets"] = ports
        config["network"] = network

        content = yaml.dump(config, Dumper=yaml.RoundTripDumper)
        path = '/etc/netplan/{}.yaml'.format(self.zstack_config_file_name('.yaml'))
        self.write_config_file(path, content)

    def _config_compare(self, ports_config):
        zstack_yaml = '/etc/netplan/' + self.zstack_config_file_name('yaml')
        content = self.read_config_file(zstack_yaml)
        if content:
            zstack_config_now = yaml.load(content, Loader=yaml.RoundTripLoader)
        else:
            return [port_config.port_name for port_config in ports_config.ports], []

        if 'network' in zstack_config_now and 'ethernets' in zstack_config_now['network']:
            zstack_ports_config = zstack_config_now['network']['ethernets']
        else:
            return [port_config.port_name for port_config in ports_config.ports], []

        changed_nic = []
        for port_config in ports_config.ports:
            try:
                port_name = port_config.port_name
                if port_name not in zstack_ports_config:
                    changed_nic.append(port_name)
                    continue

                zstack_port_config = zstack_ports_config[port_name]
                del zstack_ports_config[port_name]

                if zstack_port_config['match']['mac'] != port_config.mac or \
                        zstack_port_config["mtu"] != port_config.mtu:
                    changed_nic.append(port_name)
                    continue

                ip_config = port_config.vmIps[0]
                zstack_ip_proto = 'dhcp' if zstack_port_config.get('dhcp4') == 'yes' else 'static'
                if ip_config.proto != zstack_ip_proto:
                    changed_nic.append(port_name)
                    continue
                elif ip_config.proto == 'static':
                    ipv4 = [ip for ip in zstack_port_config['addresses'] if ip.is_ipv4(ip)]
                    zstack_ip = ipv4[0] if len(ipv4) > 0 else None
                    zstack_ip_gw = zstack_port_config['gateway4'] if 'gateway4' in zstack_port_config else None
                    zstack_ip_dns = zstack_port_config['nameservers'][
                        'addresses'][0] if 'nameservers' in zstack_port_config else None
                    if zstack_ip != ip_config.ip or \
                            zstack_ip_gw != ip_config.gateway or \
                            zstack_ip_dns != ip_config.dns:
                        changed_nic.append(port_name)
                        continue
            except Exception as e:
                # In some cases, the zstack configuration file may not meet expectations
                changed_nic.append(port_name)
                continue

        return changed_nic, [port_name for port_name in zstack_ports_config]

    def ports_config_persist(self, ports_config):

        changed_nic, deleted_nic = self._config_compare(ports_config)
        if len(changed_nic) == 0 and len(deleted_nic) == 0:
            return changed_nic

        try:
            backup = False
            if changed_nic:
                files = self.qga.guest_exec_bash_no_exitcode("ls /etc/netplan/*.yaml", exception=False)
                if files:
                    files_list = [file for file in files.split('\n')]
                    self.backup_current_config(files_list)
                    backup = True
                    self._rectify_current_config(ports_config, files_list)
            self._create_zstack_config(ports_config)
        except Exception as e:
            if backup:
                self.recover_current_config(files_list)
            raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)
        return changed_nic


class CentosPersistDriver(NetworkConfigPersistBase):
    def ports_config_recover(self, *args, **kwargs):
        pass

    # HWADDR must be specified to prevent interface name changes
    config_temp = '''# Generated by zstack customization engine.
NAME={{ iface_name }}
{% if if_type -%}
TYPE={{ if_type }}
{% endif -%}
HWADDR={{ mac_address }}
DEVICE={{ iface_name }}
{% if mtu -%}
MTU={{ mtu }}
{% endif -%}
BOOTPROTO={{ proto }}
# Keep the ip address configuration even if BOOTPROTO=dhcp
IPADDR={{ ip_address }}
NETMASK={{ netmask }}
{% if gateway -%}
GATEWAY={{ gateway }}
{% endif -%}
{% if dns -%}
DNS1={{ dns }}
{% endif -%}
ONBOOT=yes
USERCTL=no
PEERDNS=yes
{% if ipv6_config -%}
{{ ipv6_config }}
{% endif -%}
'''

    def __init__(self, qga, nm_soft_type):
        super(CentosPersistDriver, self).__init__(qga, nm_soft_type)

    def _get_current_config(self, ports_config):
        curr_config = {}
        try:
            files = self.qga.guest_exec_bash_no_exitcode("ls /etc/sysconfig/network-scripts/ifcfg-*")
            if not files:
                return curr_config
        except Exception as e:
            if 'No such file' in e.message:
                return curr_config
            else:
                raise e

        files_list = [file for file in files.split('\n') if file != ""]
        port_name_list = [port_config.port_name for port_config in ports_config.ports]
        for path in files_list:
            file_info = os.path.split(path)
            if len(file_info) < 2:
                continue

            port_name = file_info[1].split('-')[1]
            if port_name not in port_name_list:
                continue

            content = self.read_config_file(path)
            if not content:
                continue

            curr_ports_config = {}
            for line in content.split('\n'):
                info = line.split('=')
                if len(info) == 2 and not info[0].startswith('#'):
                    curr_ports_config[info[0].strip()] = info[1].strip().strip('"')
            curr_config[port_name] = curr_ports_config

        return curr_config

    def _config_compare(self, ports_config):
        """
        Port deletion is not handled here,
        the centos configuration file may not be created by zstack, which is risky
        """
        changed_nic = []
        curr_config = self._get_current_config(ports_config)

        for port_config in ports_config.ports:
            try:
                port_name = port_config.port_name
                curr_port_config = curr_config.get(port_name)
                if not curr_port_config:
                    changed_nic.append(port_name)
                    continue

                if curr_port_config.get('HWADDR') != port_config.mac or \
                        curr_port_config.get('MTU') != str(port_config.mtu):
                    changed_nic.append(port_name)
                    continue

                ip_config = port_config.vmIps[0]
                if ip_config.proto != curr_port_config.get('BOOTPROTO'):
                    changed_nic.append(port_name)
                    continue
                else:
                    if curr_port_config.get('IPADDR') != ip_config.ip or \
                            curr_port_config.get('GATEWAY') != ip_config.gateway or \
                            curr_port_config.get('DNS1') != ip_config.dns:
                        changed_nic.append(port_name)
                        continue
            except Exception as e:
                changed_nic.append(port_name)
                continue

        return changed_nic

    def ports_config_persist(self, ports_config):
        changed_nic = self._config_compare(ports_config)
        if not changed_nic:
            return changed_nic

        for port_config in ports_config.ports:
            if port_config.port_name not in changed_nic:
                continue

            try:
                path = '/etc/sysconfig/network-scripts/ifcfg-{}'.format(port_config.port_name)
                # no need to fall back when writing a new configuration file fails,
                # so there is no need to backup the current configuration
                ipv6_config = None
                content = self.read_config_file(path)
                if content:
                    ipv6_config = '\n'.join([line for line in content.split('\n') if 'IPV6' in line])

                ip4 = port_config.vmIps[0]

                template = Template(self.config_temp)
                conf = template.render(
                    mac_address=port_config.mac,
                    iface_name=port_config.port_name,
                    mtu=port_config.mtu,
                    dns=ip4.dns,
                    ip_address=ip4.ip,
                    netmask=ip4.netmask,
                    gateway=ip4.gateway,
                    proto=ip4.proto,
                    ipv6_config=ipv6_config)
                self.write_config_file(path, conf)

                if port_config.dns:
                    self.dns_config_persist(port_config.dns)

            except Exception as e:
                raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)
        return changed_nic


class UbuntuPersistDriver(NetworkConfigPersistBase):
    config_temp = '''auto {{ port_name }}
iface {{ port_name }} inet {{ proto }}
hwaddress {{ mac_address }}
{% if mtu -%}
mtu {{ mtu }}
{% endif -%}
# Keep the ip address configuration even if proto=dhcp
address {{ ip_address }}
netmask {{ netmask }}
{% if gateway -%}
gateway {{ gateway }}
{% endif -%}
{% if dns -%}
dns-nameservers {{ dns }}
{% endif -%}
'''

    def __init__(self, qga, nm_soft_type):
        super(UbuntuPersistDriver, self).__init__(qga, nm_soft_type)

    def _get_current_config(self, ports_config):
        """
        curr_config:        { port_name: {'inet': { }, 'inet6': { } } }
        reserved_config:    [], list of original config file lines that need to be kept
        """
        curr_config = {}
        reserved_config = []
        cnt, content = self.qga.guest_file_read('/etc/network/interfaces')
        if not content:
            return curr_config, reserved_config

        """
        the ubuntu 'interfaces' file consists of zero or more "iface", "mapping", "auto", "allow-", 
        "source" and "source-directory" stanzas.
        """
        keys = ['auto', 'allow-', 'source', 'source-directory', 'mapping', 'iface']
        new_port_list = [port_config.port_name for port_config in ports_config.ports]

        in_iface = False
        for line in content.split('\n'):
            if line.strip().startswith('#'):
                continue

            info = [x for x in line.strip().split(' ') if x != '']
            key = info[0].strip() if len(info) > 1 else None

            if key in ['source', 'source-directory']:
                continue
            if key == 'auto' and \
                    (len(info) < 2 or info[1].strip() in new_port_list):
                continue

            if key == 'iface' and len(info) == 4:
                port_name = info[1].strip()
                inet = info[2].strip()
                port_items = {'proto': info[3]}
                port_config = curr_config.get(port_name)
                if port_config:
                    port_config[inet] = port_items
                else:
                    port_config = {inet: port_items}
                    curr_config[port_name] = port_config
                in_iface = True
            elif key in keys:
                in_iface = False
            elif in_iface and len(info) > 1:
                port_items[info[0]] = info[1]
            # only overwrite the configuration that meets the requirements:
            #    in_iface and ipv4 and port_name in new_port_list
            if not in_iface or \
                    port_name not in new_port_list or \
                    inet != 'inet':
                reserved_config.append(line)

        return curr_config, reserved_config

    @staticmethod
    def _compare_config(ports_config, curr_config):
        changed_nic = []

        for port_config in ports_config.ports:
            try:
                port_name = port_config.port_name
                if port_name not in curr_config or \
                        'inet' not in curr_config[port_name]:
                    changed_nic.append(port_name)
                    continue

                curr_port_config = curr_config[port_name]['inet']
                if curr_port_config.get('hwaddress') != port_config.mac or \
                        curr_port_config.get('mtu') != str(port_config.mtu):
                    changed_nic.append(port_name)
                    continue

                ip_config = port_config.vmIps[0]
                if ip_config.proto != curr_port_config.get('proto'):
                    changed_nic.append(port_name)
                    continue
                else:
                    if curr_port_config.get('address') != ip_config.ip or \
                            curr_port_config.get('gateway') != ip_config.gateway or \
                            curr_port_config.get('dns-nameservers') != ip_config.dns:
                        changed_nic.append(port_name)
                        continue
            except Exception as e:
                changed_nic.append(port_name)
                continue

        return changed_nic

    def _create_zstack_config(self, ports_config, reserved_config):
        zstack_config = [self.config_start_comment()]
        zstack_config.extend(reserved_config)

        for port_config in ports_config.ports:
            port_name = port_config.port_name
            template = Template(self.config_temp)
            ip4 = port_config.vmIps[0]

            conf = template.render(
                mac_address=port_config.mac,
                port_name=port_name,
                mtu=port_config.mtu,
                dns=ip4.dns,
                ip_address=ip4.ip,
                netmask=ip4.netmask,
                gateway=ip4.gateway,
                proto=ip4.proto)
            zstack_config.extend(conf.split('\n'))

            if port_config.dns:
                self.dns_config_persist(port_config.dns)

        self.qga.guest_file_write('/etc/network/interfaces', '\n'.join(zstack_config))

    def ports_config_persist(self, ports_config):

        curr_config, reserved_config = self._get_current_config(ports_config)
        changed_nic = self._compare_config(ports_config, curr_config)
        if len(changed_nic) == 0:
            return changed_nic
        try:
            self._create_zstack_config(ports_config, reserved_config)
        except Exception as e:
            raise QgaException(ERROR_CODE_VM_CONFIG_PERSISTENCE_FAILED, e.message)
        return changed_nic


def get_virt_domain(vmUuid):
    try:
        @vm_plugin.LibvirtAutoReconnect
        def call_libvirt(conn):
            return conn.lookupByName(vmUuid)

        return call_libvirt(vmUuid)
    except libvirt.libvirtError as e:
        error_code = e.get_error_code()
        if error_code == libvirt.VIR_ERR_NO_DOMAIN:
            return None
        err = 'error happened when looking up vm[uuid:%(uuid)s], libvirt error code: %(error_code)s, %(e)s' % locals()
        raise libvirt.libvirtError(err)


def get_vm_qga_states():
    @vm_plugin.LibvirtAutoReconnect
    def get_domains(conn):
        dom_ids = conn.listDomainsID()
        doms = []
        for dom_id in dom_ids:
            try:
                domain = conn.lookupByID(dom_id)
            except libvirt.libvirtError as ex:
                if ex.get_error_code() == libvirt.VIR_ERR_NO_DOMAIN:
                    continue
                raise ex

            doms.append(domain)
        return doms

    qga_states = {}
    domains = get_domains()
    for domain in domains:
        uuid = domain.name()
        if uuid.startswith("guestfs-"):
            continue
        if uuid == "ZStack Management Node VM":
            continue
        (state, _, _, _, _) = domain.info()
        if state != vm_plugin.Vm.VIR_DOMAIN_RUNNING:
            qga_states[uuid] = {state: Qga.QGA_STATE_NOT_RUNNING}
            continue
        try:
            qga = Qga(domain)
        except Exception as e:
            continue

        qga_state = {'state': qga.state}
        if qga.state == Qga.QGA_STATE_RUNNING:
            qga_state['version'] = qga.version
            qga_state['osType'] = '{} {}'.format(qga.os, qga.os_version) \
                if all((qga.os != 'Unknown', qga.os_version != 'Unknown')) else 'Unknown'
            if qga.os == VM_OS_WINDOWS:
                qga_state['platForm'] = 'Windows'
            elif qga.os in VM_OS_LINUX_LIST:
                qga_state['platForm'] = 'Linux'
            elif qga.os == 'Unknown':
                qga_state['platForm'] = 'Unknown'
            else:
                qga_state['platForm'] = 'Other'

        qga_states[uuid] = qga_state
    return qga_states


class VmConfigSyncResponse(kvmagent.AgentResponse):
    def __init__(self):
        super(VmConfigSyncResponse, self).__init__()
        self.errorCode = None


class VmQgaSyncResponse(kvmagent.AgentResponse):
    def __init__(self):
        super(VmConfigSyncResponse, self).__init__()
        self.states = None


class QgaException(Exception):
    """ The base exception class for all exceptions this agent raises."""

    def __init__(self, error_code, msg=None):
        self.error_code = error_code
        super(QgaException, self).__init__('QGA exception' if msg is None else msg)


class VmQgaPlugin(kvmagent.KvmAgent):
    VM_QGA_CONFIG_PORTS = "/vm/configsync/ports"
    VM_QGA_SYNC = "/vm/qgasync"

    @kvmagent.replyerror
    def vm_config_ports(self, req):
        cmd = jsonobject.loads(req[http.REQUEST_BODY])
        rsp = VmConfigSyncResponse()

        domain = get_virt_domain(cmd.vmUuid)
        if not domain or not domain.isActive():
            rsp.errorCode = ERROR_CODE_VM_NOT_RUNNING

        try:
            config_driver = VmConfigDriverBase.get_driver(domain)
            config_driver.ports_config(cmd.portsConfig)
        except QgaException as e:
            rsp.errorCode = e.error_code
            rsp.error = e.message

        return jsonobject.dumps(rsp)

    @kvmagent.replyerror
    def vm_qga_sync(self, req):
        rsp = VmQgaSyncResponse()
        rsp.states = get_vm_qga_states()
        return jsonobject.dumps(rsp)

    def start(self):
        http_server = kvmagent.get_http_server()
        http_server.register_async_uri(self.VM_QGA_CONFIG_PORTS, self.vm_config_ports)
        http_server.register_async_uri(self.VM_QGA_SYNC, self.vm_qga_sync)

    def stop(self):
        pass

    def configure(self, config=None):
        pass
