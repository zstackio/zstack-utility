# Use network installation
url --url={{ network_inst_uri }}

# Text mode
text

# Hardware inspector
%pre --interpreter /bin/bash
if [ ! -f /usr/bin/python ];then
   [ -f /usr/bin/python2 ] && ln -s /usr/bin/python2 /usr/bin/python
   [ -f /usr/bin/python3 ] && ln -s /usr/bin/python3 /usr/bin/python
fi
%end

%pre --interpreter /usr/bin/python
import subprocess
import json
import multiprocessing
import os
import sys
import platform

PROVISION_NET = "{{ provision_net }}"

units_mapping = {
    'kb': 1024,
    'mb': 1024 * 1024,
    'gb': 1024 * 1024 * 1024
}

def shell_cmd(cmd, exception=True, workdir=None):
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE, close_fds=True, executable='/bin/bash', cwd=workdir)

    (stdout, stderr) = process.communicate()
    return_code = process.returncode
    if exception and return_code != 0:
        raise Exception("Failed to exec: [{}]".format(cmd))

    # the type of results is bytes in python3
    if sys.version_info.major == 3:
        stdout = stdout.decode()
        stderr = stderr.decode()

    return return_code, stdout.strip(), stderr.strip()


def get_ipmi_info():
    addr = None
    port = None
    for channel in range(0, 15):
        cmd = 'ipmitool lan print %s' % channel
        _, stdout, _ = shell_cmd(cmd, False)
        for line in stdout.split('\n'):
            if 'IP Address' in line and 'Source' not in line:
                temp_addr = line.split(':')[-1].strip()
                if temp_addr != '0.0.0.0':
                    addr = temp_addr
                break

    #cmd = 'ipmitool sol info 1'
    #_, stdout, _ = shell_cmd(cmd)
    #for line in stdout.split('\n'):
    #    if 'Payload Port' in line:
    #        port = int(line.split(':')[-1].strip())

    if not addr:
        raise Exception('Failed to find ipmi address')

    #if not port:
    port = 623

    return {
        'ipmiAddress': addr,
        'ipmiPort': port
    }


def get_boot_mode():
    if os.path.exists('/sys/firmware/efi'):
        return 'UEFI'
    return 'Legacy'


def get_basic_info():
    arch = os.uname()[-1]
    cpu_model_name = ''
    cpu_num = multiprocessing.cpu_count()
    memory_bytes = 0

    # Get memory total
    if platform.machine() == 'aarch64':
        with open('/proc/meminfo', 'r') as f:
            for line in f.readlines():
                if 'MemTotal' in line:
                    _, size, unit = line.lower().split()
                    memory_bytes = int(size) * units_mapping[unit]
                    break
    else:
        _, stdout, _ = shell_cmd('dmidecode --type memory')
        for line in stdout.split('\n'):
            line = line.lower().strip()
            if line.startswith('size') and 'no module' not in line:
                _, size, unit = line.split()
                memory_bytes += int(size) * units_mapping[unit]

    with open('/proc/cpuinfo', 'r') as f:
        for line in f.readlines():
            if 'model name' in line:
                cpu_model_name = line.split(':')[1].strip()
                break

    return {
        'architecture': arch,
        'cpuModelName': cpu_model_name,
        'cpuNum': str(cpu_num),
        'memorySize': str(memory_bytes),
        'bootMode': get_boot_mode()
    }


def get_nic_info():
    # Get the pxe interface from /proc/cmdline
    # NOTE: Need to point that the mac addr should start with '01', because
    # the arp type of ethernet is 1.
    pxe_iface_mac = ''
    with open('/proc/cmdline', 'r') as f:
        for param in f.read().strip().split():
            if 'BOOTIF' in param:
                pxe_iface_mac = param.split('=')[-1].replace('-', ':')

    net_devs = []
    for net_dev in os.listdir('/sys/class/net'):
        abspath = os.path.join('/sys/class/net', net_dev)

        realpath = os.path.realpath(abspath)
        if 'virtual' in realpath or (net_dev == 'lo'):
            continue

        try:
            with open(os.path.join(abspath, 'speed'), 'r') as f:
                speed = '%sMb/s' % f.read().strip()
        except Exception:
            speed = 'UNKNOWN'
        with open(os.path.join(abspath, 'address'), 'r') as f:
            mac_address = f.read().strip()

        rc, _, _ = shell_cmd("""arping -c 5 -I {} {}""".format(net_dev, PROVISION_NET), False)
        if rc == 0 and not pxe_iface_mac:
            is_provision_nic = True
            pxe_iface_mac = mac_address

        is_provision_nic = True if mac_address in pxe_iface_mac else False

        net_devs.append({
            'nicMac': mac_address,
            'nicSpeed': speed,
            'isProvisionNic': is_provision_nic
        })
    return net_devs


def get_disk_info():
    block_devs = []

    cmd = 'lsblk --nodeps --byte --output name,size,rota,type'
    _, stdout, _ = shell_cmd(cmd)
    for line in stdout.split('\n')[1:]:
        if len(line.split()) != 4:
            continue
        name, size, rotation, blk_type  = line.split()

        if blk_type.lower() != 'disk':
            continue

        disk_type = 'SSD' if rotation == '0' else 'HDD'
        _, wwn, _ = shell_cmd("smartctl -i /dev/%s | awk '/Logical Unit id/{print $4}'" % name)
        block_devs.append({
            'diskType': disk_type,
            'diskSize': size,
            'wwn': wwn
        })

    return block_devs


def main():
    """ Inspect

    return::
    {
        'params': {
            'ipmiAddress': '10.0.0.1',
            'ipmiPort': 623,
            'hardwareInfo': '{
                "architecture": "x86_64",
                "cpuModelName": "Intel(R) Xeon(R) CPU E4-2670 v3 @ 2.30GHz,
                "cpuNum": 24,
                "memorySize": 33421254656,
                "disks": [
                    {
                        "diskType": "HDD",
                        "diskSize": "20737418240"
                    },
                    {
                        "diskTYpe": "SSD",
                        "diskSize": "20737418240"
                    }
                ],
                "nics": [
                    {
                        "nicMac": "aa:bb:cc:dd:ee:ff",
                        "nicSpeed": "1000Mb/s",
                        "isProvisionNic": false
                    },
                    {
                        "nicMAc": "aa:bb:cc:dd:ee:fe",
                        "nicSpeed": "1000Mb/s",
                        "isProvisionNic": true
                    }
                ]
            }'
        }
    }
    """
    result = {}
    result.update(get_ipmi_info())

    hardware_info = {}
    hardware_info.update(get_basic_info())
    hardware_info['nics'] = get_nic_info()
    hardware_info['disks'] = get_disk_info()

    result['hardwareInfo'] = json.dumps(hardware_info)

    cmd = ('curl -X POST -H "Content-Type:application/json" -d \'{data}\' '
           '--retry 5 {{ send_hardware_infos_uri }} ').format(
               data=json.dumps({"params": result}))
    shell_cmd(cmd)

    shell_cmd("poweroff")


main()


%end
