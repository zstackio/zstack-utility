# Use network installation
url --url={{ network_inst_uri }}

# Text mode
text

# Hardware inspector
%pre --interpreter /bin/bash
if [ ! -f /usr/bin/python ];then
   [ -f /usr/bin/python2 ] && ln -s /usr/bin/python2 /usr/bin/python
   [ -f /usr/bin/python3 ] && ln -s /usr/bin/python3 /usr/bin/python
fi
%end

%pre --interpreter /usr/bin/python
import subprocess
import json
import multiprocessing
import os
import sys


units_mapping = {
    'kb': 1024,
    'mb': 1024 * 1024,
    'gb': 1024 * 1024 * 1024
}

def shell_cmd(cmd, exception=True, workdir=None):
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE, close_fds=True, executable='/bin/bash', cwd=workdir)

    (stdout, stderr) = process.communicate()
    return_code = process.returncode
    if exception and return_code != 0:
        raise Exception("Failed to exec: [{}]".format(cmd))

    # the type of results is bytes in python3
    if sys.version_info.major == 3:
        stdout = stdout.decode()
        stderr = stderr.decode()

    return return_code, stdout.strip(), stderr.strip()


def get_ipmi_info():
    addr = None
    port = None
    for channel in range(0, 15):
        cmd = 'ipmitool lan print %s' % channel
        _, stdout, _ = shell_cmd(cmd, False)
        for line in stdout.split('\n'):
            if 'IP Address' in line and 'Source' not in line:
                temp_addr = line.split(':')[-1].strip()
                if temp_addr != '0.0.0.0':
                    addr = temp_addr
                break

    #cmd = 'ipmitool sol info 1'
    #_, stdout, _ = shell_cmd(cmd)
    #for line in stdout.split('\n'):
    #    if 'Payload Port' in line:
    #        port = int(line.split(':')[-1].strip())

    if not addr:
        raise Exception('Failed to find ipmi address')

    #if not port:
    port = 623

    return {
        'ipmiAddress': addr,
        'ipmiPort': port
    }


def get_boot_mode():
    if os.path.exists('/sys/firmware/efi'):
        return 'UEFI'
    return 'Legacy'


def get_basic_info():
    arch = os.uname()[-1]
    cpu_model_name = ''
    cpu_num = multiprocessing.cpu_count()

    # Get memory total
    memory_bytes = 0
    _, stdout, _ = shell_cmd('dmidecode --type memory')
    for line in stdout.split('\n'):
        line = line.lower().strip()
        if line.startswith('size') and 'no module' not in line:
            _, size, unit = line.split()
            memory_bytes += int(size) * units_mapping[unit]

    with open('/proc/cpuinfo', 'r') as f:
        for line in f.readlines():
            if 'model name' in line:
                cpu_model_name = line.split(':')[1].strip()
                break

    return {
        'architecture': arch,
        'cpuModelName': cpu_model_name,
        'cpuNum': str(cpu_num),
        'memorySize': str(memory_bytes),
        'bootMode': get_boot_mode()
    }


def get_nic_info():
    # Get the pxe interface from /proc/cmdline
    # NOTE: Need to point that the mac addr should start with '01', because
    # the arp type of ethernet is 1.
    pxe_iface_mac = ''
    with open('/proc/cmdline', 'r') as f:
        for param in f.read().strip().split():
            if 'BOOTIF' in param:
                pxe_iface_mac = param.split('=')[-1].replace('-', ':')

    if not pxe_iface_mac:
        _, pxe_iface_name, _ = shell_cmd("ip route | awk '/default/ { print $5 }' | head -n 1")
        if not pxe_iface_name:
            _, pxe_iface_name, _ = shell_cmd("ip route | awk '{ print $3 }' | head -n 1")
        with open("/sys/class/net/%s/address" % pxe_iface_name, 'r') as f:
            pxe_iface_mac = f.read().strip()

    net_devs = []
    for net_dev in os.listdir('/sys/class/net'):
        abspath = os.path.join('/sys/class/net', net_dev)

        realpath = os.path.realpath(abspath)
        if 'virtual' in realpath:
            continue

        try:
            with open(os.path.join(abspath, 'speed'), 'r') as f:
                speed = '%sMb/s' % f.read().strip()
        except Exception:
            speed = 'UNKNOWN'
        with open(os.path.join(abspath, 'address'), 'r') as f:
            mac_address = f.read().strip()

        is_provision_nic = True if mac_address in pxe_iface_mac else False

        net_devs.append({
            'nicMac': mac_address,
            'nicSpeed': speed,
            'isProvisionNic': is_provision_nic
        })
    return net_devs


def get_disk_info():
    block_devs = []

    cmd = 'lsblk --nodeps --byte --output size,rota,type,wwn'
    _, stdout, _ = shell_cmd(cmd)
    for line in stdout.split('\n')[1:]:
        if len(line.split()) != 4:
            continue
        size, rotation, type, wwn = line.split()

        if type.lower() != 'disk':
            continue

        disk_type = 'SSD' if rotation == '0' else 'HDD'

        block_devs.append({
            'diskType': disk_type,
            'diskSize': size,
            'wwn': wwn
        })

    return block_devs


def main():
    """ Inspect

    return::
    {
        'params': {
            'ipmiAddress': '10.0.0.1',
            'ipmiPort': 623,
            'hardwareInfo': '{
                "architecture": "x86_64",
                "cpuModelName": "Intel(R) Xeon(R) CPU E4-2670 v3 @ 2.30GHz,
                "cpuNum": 24,
                "memorySize": 33421254656,
                "disks": [
                    {
                        "diskType": "HDD",
                        "diskSize": "20737418240"
                    },
                    {
                        "diskTYpe": "SSD",
                        "diskSize": "20737418240"
                    }
                ],
                "nics": [
                    {
                        "nicMac": "aa:bb:cc:dd:ee:ff",
                        "nicSpeed": "1000Mb/s",
                        "isProvisionNic": false
                    },
                    {
                        "nicMAc": "aa:bb:cc:dd:ee:fe",
                        "nicSpeed": "1000Mb/s",
                        "isProvisionNic": true
                    }
                ]
            }'
        }
    }
    """
    result = {}
    result.update(get_ipmi_info())

    hardware_info = {}
    hardware_info.update(get_basic_info())
    hardware_info['nics'] = get_nic_info()
    hardware_info['disks'] = get_disk_info()

    result['hardwareInfo'] = json.dumps(hardware_info)

    cmd = ('curl -X POST -H "Content-Type:application/json" -d \'{data}\' '
           '--retry 5 {{ send_hardware_infos_uri }} ').format(
               data=json.dumps({"params": result}))
    shell_cmd(cmd)

    shell_cmd("poweroff")


main()


%end
